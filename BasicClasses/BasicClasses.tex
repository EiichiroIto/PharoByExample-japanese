% $Author$
% $Date$
% $Revision$

% HISTORY:
% 2006-10-31 - Oscar started
% 2007-08-19 - Stef revised
% 2007-11-09 - Andrew corrections
% 2008-03-28 - Cassou corrections
% 2009-07-07 - Oscar fixed broken tests

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
  \documentclass[a4paper,10pt,twoside]{book}
  \usepackage[
    papersize={6.13in,9.21in},
    hmargin={.75in,.75in},
    vmargin={.75in,1in},
    ignoreheadfoot
  ]{geometry}
  \input{../common.tex}
  \pagestyle{headings}
  \setboolean{lulu}{true}
% --------------------------------------------
% A4:
% \documentclass[a4paper,11pt,twoside]{book}
% \input{../common.tex}
% \usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
  \begin{document}
  \renewcommand{\nnbb}[2]{} % Disable editorial comments
  \sloppy
\fi
%=================================================================
\chapter{基本的なクラス}
\chalabel{basic}

Smalltalkの魔法の大部分は、言語そのものではなくクラスライブラリにあります。Smalltalkで効率的にプログラミングするには、クラスライブラリがどのように言語や環境を支えているのか学ばなければなりません。クラスライブラリはすべてがSmalltalkで記述されていて、パッケージ(クラス定義を含んでいる必要はありません)を使えば新しい機能をクラスに追加できるため、簡単に拡張することができます。

この章の目的は、\pharo のクラスライブラリ全体について詳細で長くつまらない話をすることではありません。代わりにここでは、プログラムを効率的に利用したり書き換えるのに必要な核となるクラスやメソッドについて指摘します。本章では、ほぼすべてのアプリケーションで必要になると思われる次の基本的なクラスを取り上げます: \ct{Object}、\ct{Number}とそのサブクラス、\ct{Character}、\ct{String}、\ct{Symbol}、\ct{Boolean}。

\md{Here are some comments:\\
- copying: Good question... the copying in \pharo  is much too complicated... there is for one the "old" smalltalk way of
  overrifing postCopy, and then the "automatic" deepCopy... which is quite complex and (I think) was no good idea...
 (see class comment in  DeepCopier)\\
- Debugging: Yes, needs its own chapter. We should talk about haltIf, haltOnce...\\
- assert: Object>>>assert: can take both a block and a boolean, because boleen implements \#value.
  (I will fix SUnit to allow both, too).\\
- Characters and Strings: we should talk about Unicode stuff... but I don't know too much myself.}

%=================================================================
\section{Object}
あらゆる意味で、\clsindmain{Object}クラスは継承階層のルートです。本当のところ、\pharo では\clsind{ProtoObject}クラスが階層の真のルートです。\ct{ProtoObject}はオブジェクトとして振舞うことができる最小の実体を定義するために使用されます。しかし、今このことは気にしなくていいでしょう。
% (後ほどリフレクションの章で詳しく説明します)。

\ct{Object}クラスは\scatind{Kernel-Objects}カテゴリの中にあります。そこには(拡張((とは?))も含めると)400ものメソッドがあるということにきっと驚くでしょう。これはつまり、新しいクラスを定義すると、あなたがそれを知っていようといまいと、すべてに自動的に400個のメソッドが提供されるということです。ただ、削除されるべき不要なメソッドもいくつかあり、\pharo の新しいバージョンではそれらの不要なメソッドのいくつかはおそらく削除されることになることを覚えておきましょう。

\sd{変更される可能性のあるものを引用することは好みませんし、簡単に一覧を見つけられるので、今のところはそのままにしておきます。}
\ct{Object}クラスのクラスコメントには次のように書かれています:

\needlines{4}
\begin{quote}
\textit{\ct{Object}クラスはクラス階層内のほぼすべてのクラスのルートクラスである。例外は\ct{ProtoObject}クラス(\ct{Object}のスーパークラス)とその直接のサブクラスである。
\ct{Object}クラスは通常のオブジェクトのアクセス、コピー、比較、エラー処理、メッセージ送信、\ind{リフレクション}などのデフォルトの振舞いを提供する。また、すべてのオブジェクトが反応する必要があるユーティリティメッセージもここで定義される。
\ct{Object}はインスタンス変数を持っておらず、追加すべきでもない。これは\ct{Object}を継承するクラス((classes of objects))には特殊な実装を持つもの(例えば\ct{SmallInteger}や\ct{UndefinedObject})がいくつかあって、これらやVMが、ある標準的なクラスの構造とレイアウトを知っていてそれに依存しているためである。}
\end{quote}

\ct{Object}のインスタンスボタン側のメソッドカテゴリをブラウズすると、提供されているいくつかの主だった振舞いが理解できるようになるでしょう。

%-----------------------------------------------------------------
\subsection{表示}
Smalltalkのすべてのオブジェクトは、自分自身を表示用の形式で返すことができます。ワークスペースで好きな式を選び、\menu{print it}メニューを選択してください: \menu{print it}は式を実行し、返されたオブジェクトにそれ自身を表示するよう頼みます。実際には、返されたオブジェクトに\ct{printString}メッセージを送信します。\mthind{Object}{printString}は\ind{テンプレートメソッド}で、その中で\mthind{Object}{printOn:}をレシーバーに送信します。\ct{printOn:}メッセージはフックメソッドで特殊化することができます。

おそらく\ct{Object>>>printOn:}は最も頻繁にオーバーライドされるメソッドのひとつになるでしょう。このメソッドは引数に\clsind{Stream}を受け取り、そこにオブジェクトの\clsind{String}表現を書き込みます。デフォルトの実装は単純に「\ct{a}」または「\ct{an}」の後にクラス名を書きこむだけです。\ct{Object>>>printString}は、引数(\ct{aStream})に書きこまれたものを\ct{String}にして返します。

例えば\clsind{Browser}クラスは\ct{printOn:}メソッドを再定義していないので、printStringメソッドを\ct{Browser}のインスタンスに送ると\ct{Object}で定義されたメソッドが実行されます。
\begin{code}{@TEST}
Browser new printString --> 'a Browser'
\end{code}

\ct{Color}では\mthind{Color}{printOn:}を特殊化した例が見られます。
実行するとクラスの名前に続いて色を生成するためのメッセージ式(\ct{Color 色名})を、引数(\ct{aStream})に書き込みます。

\needlines{7}
\begin{method}[zork]{printOn:の再定義。}
Color>>>printOn: aStream
  | name |
  (name := self name) ifNotNil: 
    [ ^ aStream
      nextPutAll: 'Color ';
      nextPutAll: name ].
  self storeOn: aStream
\end{method}\ignoredollar$

\begin{code}{@TEST}
Color red printString --> 'Color red'
\end{code}

\ct{printOn:}メッセージは\mthind{Object}{storeOn:}メッセージとは異なることに注意してください。\ct{storeOn:}メッセージはレシーバーを再生成するのに利用できる式を、引数として受け取ったストリームに流します。そしてストリームが\ct{readFrom:}メッセージによって読み込まれるときにその式が評価されます。一方、\ct{printOn:}は単にレシーバーの文字列バージョンを返すだけです。もちろん、その文字列表現がレシーバーの自己評価型の表現ということもありえます。

\paragraph{表現と自己評価型表現という単語について。}
関数型プログラミングでは、式は実行されると値を返します。一方Smalltalkでは、メッセージ(式)はオブジェクト(値)を返します。オブジェクトの中には自分自身を表す値を持つ便利な特性を持つものがあります。例えば、\ct{true}オブジェクトの値はそれ自身、\ie\ct{true}オブジェクトです。このようなオブジェクトは\emphind{自己評価型オブジェクト}と呼ばれます。ワークスペースでオブジェクトをprint((print it?))すると、オブジェクトの値の\emph{プリントされた}バージョンを見ることができます。次のものが自己評価型表現の例です。

\begin{code}{@TEST}
true         --> true
3@4       --> 3@4
$a           --> $a
#(1 2 3)   --> #(1 2 3)
Color red --> Color red
\end{code}

配列のようなオブジェクトはそこに含まれるオブジェクトによって自己評価型であったり、そうでは無かったりすることに注意して下さい。例えば、真偽値の配列は自己評価型ですが、personオブジェクトの配列はそうではありません。
次の例は、\subind{配列}{動的}配列が要素も自己評価型である場合だけ自己評価型になることを示しています:
\begin{code}{@TEST}
{10@10. 100@100}           --> {10@10. 100@100}
{Browser new . 100@100} --> an Array(a Browser 100@100)
\end{code}

\subind{Array}{リテラル}配列はリテラルだけを保持できることに注意して下さい。そのため、次の配列は二つの座標を保持するのではなく、6個のリテラルを持つことになります。
\begin{code}{@TEST}
#(10@10 100@100) --> #(10 #@ 10 100 #@ 100)
\end{code}

\ct{printOn:}メソッドの多くは、自己評価型としての振る舞いを実装するように特殊化されています。例えば\cmind{Point}{printOn:}や\cmind{Interval}{printOn:}の実装は自己評価型です。

\begin{method}[Self-evaluating points]{\ct{Point}の自己評価型\protect\footnote{訳注：\pharo 1.3ではコードが変更されています}}
Point>>>printOn: aStream 
    "レシーバーは中置記法でaStream上に書き込まれる"
    x printOn: aStream.
    aStream nextPut: $@.
    y printOn: aStream
\end{method}\ignoredollar$

\begin{method}[Self-evaluating intervals]{\ct{Interval}の自己評価型}
Interval>>>printOn: aStream
    aStream nextPut: $(;
        print: start;
        nextPutAll: ' to: ';
        print: stop.
    step ~= 1 ifTrue: [aStream nextPutAll: ' by: '; print: step].
    aStream nextPut: $)
\end{method}

\begin{code}{@TEST}
1 to: 10 --> (1 to: 10)    "Intervalオブジェクトは自己評価型"
\end{code}

%-----------------------------------------------------------------
\subsection{同一性と同値性}

Smalltalkでは、\ct{=}メッセージは\emphsubindmain{Object}{同値性}をテストします(\ie 二つのオブジェクトが同じ値を持つかどうか)。一方\ct{==}は\emphsubindmain{Object}{同一性}をテストします(\ie 二つの表現が同じオブジェクトを示すかどうか)\footnote{訳注：これらのメッセージはcomparingカテゴリにあります}。
\seeindex{\ct{=}}{Object, 同値性}
\seeindex{\ct{==}}{Object, 同一性}
\seeindex{equality}{Object, 同値性}
\seeindex{identity}{Object, 同一性}

オブジェクトの同値性チェックのデフォルトの実装ではオブジェクトの同一性をテストします:
\begin{method}{オブジェクトの同値性}
Object>>>= anObject
    "レシーバと引数が同じ値を持つかどうか答える。
    もし = をサブクラスによって再定義するなら、hashメッセージの再定義も検討すること。"
    ^ self == anObject
\end{method}
\cmindex{Object}{=}

これは頻繁にオーバーライドされることのあるメソッドです。\ct{Complex}(複素数)の場合を見てみましょう\footnote{訳注：\ct{Complex}クラスは\pharo 1.3に存在しません}:

\begin{code}{@TEST}
(1 + 2 i) = (1 + 2 i)   --> true     "同じ値"
(1 + 2 i) == (1 + 2 i) --> false    "だけど、違うオブジェクト"
\end{code}

このように動作するのは\ct{Complex}が\ct{=}を次のようにオーバーライドしているからです:
\cmindex{Complex}{=}
\needlines{5}
\begin{method}{複素数の同値性}
Complex>>>= anObject
    anObject isComplex
        ifTrue: [^ (real = anObject real) & (imaginary = anObject imaginary)]
        ifFalse: [^ anObject adaptToComplex: self andSend: #=]
\end{method}

\ct{Object>>>~=}のデフォルトの実装は単純に\ct{Object>>>=}を反転しているだけですが、通常は変更する必要はありません。
%\cmindex{Object}{\~=}
\index{Object!~=@\ct{~=}} % needs special treatment due to ~

\begin{code}{@TEST}
(1 + 2 i) ~= (1 + 4 i) --> true
\end{code}

もし\ct{=}をオーバーライドした場合は、\mthind{Object}{hash}をオーバーライドすることを検討すべきです。クラスのインスタンスが\clsind{Dictionary}のキーとして使用された場合に、同値であると見なされるインスタンスはハッシュ値が同じになるようにしておく必要があります:
\cmindex{Complex}{hash}
\begin{method}{複素数のhashは再実装されなければいけない}
Complex>>>hash
    "= を実装したのでhashも再実装する。"
    ^ real hash bitXor: imaginary hash.
\end{method}

\ct{=}と\ct{hash}は同時にオーバーライドすべきですが、\ct{==}は\emph{決して}オーバーライドしてはいけません(オブジェクトの同一性に関する意味論は、すべてのクラスで同じです)。\ct{==}は\clsind{ProtoObject}のプリミティブメソッドです。

\pharo には他のSmalltalkと比べていくつか奇妙な振舞いがあることに注意してください: 例えばシンボルと文字列は同値と見なされることがあります(これは機能ではなくバグではないかと著者らは考えています)。

\begin{code}{@TEST}
#'lulu' = 'lulu' --> true
'lulu' = #'lulu' --> true
\end{code}


%-----------------------------------------------------------------
\subsection{クラスのメンバーシップ}
いくつかのメソッドを使って、オブジェクトのクラスに関する問い合わせをすることができます。

\paragraph{\mthind{Object}{class}.} 任意のオブジェクトに対して、\ct{class}メッセージを使うことでそれが属するクラスを尋ねることができます。
\begin{code}{@TEST}
1 class --> SmallInteger
\end{code}

反対に、オブジェクトが特定のクラスのインスタンスであるかどうかを尋ねることもできます:
\cmindex{Object}{isMemberOf:}
\begin{code}{@TEST}
1 isMemberOf: SmallInteger --> true    "まさにこのクラスに属していなければならない"
1 isMemberOf: Integer          --> false
1 isMemberOf: Number        --> false
1 isMemberOf: Object           --> false
\end{code}

SmalltalkのクラスライブラリはSmalltalk自身によって記述されているので、スーパークラスとクラスメッセージを正しく組み合わせてクラスライブラリの構造を自在にたどることができます(\charef{metaclasses}を参照)。

\paragraph{\ct{isKindOf:}}
\cmind{Object}{isKindOf:}は、レシーバのクラスが引数のクラスと等しいかまたはそのサブクラスであるかどうか答えます。

\begin{code}{@TEST}
1 isKindOf: SmallInteger --> true
1 isKindOf: Integer          --> true
1 isKindOf: Number         --> true
1 isKindOf: Object           --> true
1 isKindOf: String            --> false

1/3 isKindOf: Number      --> true
1/3 isKindOf: Integer        --> false
\end{code}

\ct{1/3}は\clsind{Fraction}で、\clsind{Number}でもあります。これは\ct{Number}クラスが\ct{Fraction}クラスのスーパークラスだからです。しかし\ct{1/3}は\ct{Integer}ではありません。

\paragraph{\ct{respondsTo:}}
\cmind{Object}{respondsTo:}は、レシーバがメッセージセレクタ(\ct{respondsTo:}のシンボル引数)を理解できるかどうか答えます。

\begin{code}{@TEST}
1 respondsTo: #, --> false
\end{code}

一般的には、オブジェクトにクラスを問い合わせたり、メッセージを理解できるかどうかを尋ねたりするのは良いやり方ではありません。
オブジェクトのクラスに基づいて判断する代わりに、オブジェクトにただメッセージを送信し、どう振る舞うかはオブジェクトの(クラスに基づいた)決定に任せるべきです。

%-----------------------------------------------------------------
\subsection{オブジェクトのコピー}

オブジェクトのコピーにはいくつかちょっとした問題があります。インスタンス変数は参照によってアクセスされるので、あるオブジェクトの\emphsubind{オブジェクト}{シャローコピー}は元のオブジェクトとインスタンス変数の参照を共有することになります。
\seeindex{コピー}{Object, \ct{copy}}
\seeindex{シャローコピー}{Object, \ct{shallowCopy}}
\seeindex{ディープコピー}{Object, \ct{deepCopy}}

\begin{code}{@TEST | a1 a2 |}
a1 := { { 'harry' } }.
a1 --> #(#('harry'))
a2 := a1 shallowCopy.
a2 --> #(#('harry'))
(a1 at: 1) at: 1 put: 'sally'.
a1 --> #(#('sally'))
a2 --> #(#('sally'))    "内側の配列が共有されている!"
\end{code}

\cmind{Object}{shallowCopy}は、オブジェクトのシャローコピーを作成するためのプリミティブメソッドです。\ct{a2}は\ct{a1}の単なるシャローコピーなので、二つの配列は、中に含まれるネストされた配列((原文: ct\{Array\}))の参照を共有しています。

\ct{Object>>>shallowCopy}は\cmind{Object}{copy}の「公開インターフェース」で、インスタンスに一意性があればオーバーライドする必要があります。例えば、\clsind{Boolean}クラス、\clsind{Character}、\clsind{SmalInteger}、\clsind{UndefinedObject}などがその例です。

\cmind{Object}{copyTwoLevel}は、単純なシャローコピーではうまくいかないときに、見たままのことを実行してくれます:

\begin{code}{@TEST | a1 a2 |}
a1 := { { 'harry' } } .
a2 := a1 copyTwoLevel.
(a1 at: 1) at: 1 put: 'sally'.
a1 --> #(#('sally'))
a2 --> #(#('harry'))    "状態は完全に独立している"
\end{code}

\cmind{Object}{deepCopy}は任意の深さまでオブジェクトをコピーします。

\begin{code}{@TEST | a1 a2 |}
a1 := { { { 'harry' } } } .
a2 := a1 deepCopy.
(a1 at: 1) at: 1 put: 'sally'.
a1 --> #(#('sally'))
a2 --> #(#(#('harry')))
\end{code}

\ct{deepCopy}の問題は、相互再帰的な構造に対して呼び出した場合に終了しなくなることです:

\begin{code}{NB: CANNOT TEST}
a1 := { 'harry' }.
a2 := { a1 }.
a1 at: 1 put: a2.
a1 deepCopy --> !\emph{... ((Japanese impossible?))does not terminate!}!
\end{code}
% NB: Not a test!

正しく動くように\ct{deepCopy}をオーバーライドすることもできますが、\cmind{Object}{copy}がもっといい解決策を提供してくれます:

\begin{method}{オブジェクトをコピーするテンプレートメソッド}
Object>>>copy
    "レシーバと同じようなもう一つのインスタンスを返す。
    サブクラスは通常、postCopyをオーバーライドする。
    通常はshallowCopyはオーバーライドしない。"
    ^self shallowCopy postCopy
\end{method}

共有されるべきではないインスタンス変数をコピーするには\mthind{Object}{postCopy}をオーバーライドしましょう。そして、\ct{postCopy}の中では常に\ct{super postCopy}しましょう。

\on{見てみたけど、システムの中にはいい例が見つかりませんでした。}

%-----------------------------------------------------------------
\subsection{デバッグ}

デバッグで最も重要なメソッドが\mthind{Object}{halt}です\footnote{訳注：実際にはerror handlingカテゴリにhaltは分類されています}。メソッドにブレークポイントを設定するには、単にメソッド本文の好きな場所に\ct{self halt}というメッセージ送信を挿入するだけで構いません。このメッセージが送信されると、プログラムのその位置で実行が中断され\ind{デバッガ}が起動します
(デバッガのさらに詳細な内容については\charef{env}を参照してください)。

\sd{他の章ではhaltIf:、haltOnce、inspectOnce、flagging: isThisEverCalledなども紹介されています。}

次の最も重要なメッセージは\mthind{Object}{assert:}です。これは引数として\ind{ブロック}を取ります。ブロックが\ct{true}を返すと、実行は継続されます。そうでなければ\ct{AssertionFailure}例外が発生します。この例外がキャッチされなければ、例外の発生した位置でデバッガが開きます。\ct{assert:}は\emphind{契約による設計}をサポートするのに特に便利です。オブジェクトのパブリックなメソッドの重要な((non-trivial))事前条件をチェックするというのが最もよくある利用方法でしょう。\cmind{Stack}{pop}は次のように簡単に実装できます:

\begin{method}{事前条件のチェック}
Stack>>>pop
    "最初の要素を返し、スタックからそれを削除します。"
    self assert: [ self isEmpty not ].
    ^self linkedList removeFirst element
\end{method}

\ct{Object>>>assert:}と\cmind{TestCase}{assert:}を混同しないでください。後者はSUnitテスティングフレームワーク(\charef{SUnit}を参照)の中で出てきます。前者は引数としてブロックを期待する\footnote{実際には\ct{value}メッセージを解釈できる、\ct{Boolean}を含む、あらゆる引数を受け取れます}のに対し、後者は\clsind{Boolean}を期待します。共にデバッグのために有用ですが、それぞれ目的は大きく異なります。

%-----------------------------------------------------------------
\subsection{エラー処理}

このプロトコルにはランタイムエラーを通知するのに便利なメソッドがいくつか含まれます。

\lct{self deprecated: \emph{anExplanationString}}を送信すると、そのメソッドは今後使うべきではないということが通知できます(\ind{プリファレンスブラウザ}の\protind{debug}プロトコルでdeprecationをオンにしているとき)。
引数として代わりの選択肢を\ct{String}で提示します。
\cmindex{Object}{deprecated:}
\index{deprecation}

\begin{code}{NB: CANNOT TEST}
1 doIfNotNil: [ :arg | arg printString, ' is not nil' ]
  --> !\emph{SmallInteger(Object)>>doIfNotNil: has been deprecated. use ifNotNilDo:}!
\end{code}

メソッド探索((message lookup))に失敗すると\ct{doesNotUnderstand:}が送信されます。デフォルトの実装、\ie\cmind{Object}{doesNotUnderstand:}では、その位置でデバッガが起動します。\lct{does\-Not\-Un\-der\-stand:}をオーバーライドして他の振る舞いをさせると便利かもしれません。

\on{例外についての章を書いたらその章への参照を追加すること。}

\cmind{Object}{error}と\cmind{Object}{error:}は例外を発生させるために利用できる一般的なメソッドです
(ただし、独自に定義した例外を発生させる方が、自分のコードとカーネルクラスのどちらで発生したエラーなのかを区別できるので、一般的には望ましいでしょう)。
\lr{おそらく独自の例外を自分で作成した方がいいということに触れています(p. 208)}

Smalltalkの抽象メソッドは、規約によりメソッドの本文に\lct{self sub\-class\-Res\-pon\-si\-bi\-li\-ty}と書いて実装します。抽象クラスが間違ってインスタンス化され、抽象メソッドが呼び出されたとしても、\cmind{Object}{subclassResponsibility}が評価されるだけです。

\begin{method}{メソッドが抽象メソッドであることを示す\protect\footnote{訳注：この例は\pharo 1.3では変更されています}}
Object>>>subclassResponsibility
    "((他で見たような気がする))This message sets up a framework for the behavior of the class' subclasses.
    Announce that the subclass should have implemented this message."
    self error: 'My subclass should have overridden ', thisContext sender selector printString
\end{method}

\clsind{Magnitude}と\clsind{Number}と\clsind{Boolean}が\subind{クラス}{抽象}クラスの古典的な例です。この章の少し先で説明します。

\begin{code}{NB: CANNOT TEST}
Number new + 1 --> !\emph{エラー: \#+はサブクラスでオーバーライドしなければならない}!
\end{code}

((規約によりサブクラスが継承すべきではないメソッドを示すには\ct{self shouldNotImplement}を送信します))。これは一般的にはクラス階層の設計が何かうまくいっていないことのサインです。しかし、単一継承の制限があるため、このような回避策を避けることが非常に難しい場合もあります((もう少し何とかならないか?))。
\cmindex{Object}{shouldNotImplement}
\index{inheritance!canceling}

典型的な例は、\clsind{Dictionary}で継承したけれど未実装であるというフラグを立てている\cmind{Collection}{remove:}です((本当?))(\ct{Dictionary}は代わりに\mthind{Dictionary}{removeKey:}を用意しています)。

%-----------------------------------------------------------------
\sd{ subsection{廃止予定} }
\sd{あとで書く}

\on{既に上にいくつか説明があります!エラー処理の二つ目の段落を参照して下さい。}

%-----------------------------------------------------------------
\subsection{testingメソッド}

\protind{testing} に分類されるメソッド(testingメソッド)はSUnitのテストとは何の関係もありません! testingメソッドはレシーバの状態((?))を聞かれて\clsind{Boolean}を答えるメソッドです。

たくさんのtestingメソッドが\ct{Object}によって提供されています。\mthind{Object}{isComplex}は既に見ました。Objectクラスにはその他にも\mthind{Object}{isArray}、\mthind{Object}{isBoolean}、\mthind{Object}{isBlock}、\mthind{Object}{isCollection}などがあります。オブジェクトに自身のクラスを問い合わせるのはカプセル化を破ることなので一般的にはこれらのメソッドの使用は避けるべきです。((testing an object for its class: オブジェクトに自身のクラスを尋ねる))のではなく、ただ要求を送信し、オブジェクト自身にその処理を任せるべきです。

とはいえ、これらのtestingメソッドのいくつかは間違いなく有用です。最も有用なのはおそらく\cmind{ProtoObject}{isNil}と\cmind{Object}{notNil}でしょう(\patind{Null Object}\cite{Wool98a}デザインパターンを使ってこれらのメソッドを不要にすることもできますが)。

% \footnote{However the \emph{Null Object} design pattern can obviate the need for even these methods. See, Bobby Woolf, ``Null Object,'' Pattern Languages of Program Design 3, Robert Martin, Dirk Riehle and Frank Buschmann (Eds.), pp. 5-18, Addison Wesley, 1998.}.

%-----------------------------------------------------------------
\subsection{initialize-releaseプロトコル}

\ct{Object}ではなく\ct{ProtoObject}にある最後のキーメソッドは\mthind{ProtoObject}{initialize}です。

\begin{method}{空のフックメソッドとしての\lct{initialize}}
ProtoObject>>>initialize
   "サブクラスはこのメソッドを再定義してインスタンス作成時に初期化を実行しなければいけない"
\end{method}

これが重要なのは、\pharo では、システム内のすべてのクラスの\mthind{Behavior}{new}メソッドのデフォルト実装が、新しく作成されたインスタンスに\ct{initialize}を送るように書かれているからです。

\begin{method}{クラス側のテンプレートメソッドとしての\lct{new}}
Behavior>>>new
    "添字付けできないレシーバ(クラス)の初期化された新しいインスタンスを返す。
    クラスが添字付けできる((indexable))場合は失敗する。"
    ^ self basicNew initialize
\end{method}
\cmindex{Behavior}{new}

これは、\ct{initialize} \ind{フックメソッド}をオーバーライドするだけで、あなたが作成したクラスの新しいインスタンスが自動的に初期化されるということを意味しています。通常、\ct{initialize}メソッドでは継承されたすべてのインスタンス変数についてクラスの\subind{クラス}{不変条件}を確立するために\ct{super initialize}を実行する必要があります
(これは他のSmalltalkでは標準の振る舞い\emph{ではない}ことに注意して下さい)。

%=================================================================
\section{Number}
\seclabel{Number}
驚くべきことに、Smalltalkで数値はプリミティブなデータの値ではなく本当のオブジェクトです。もちろん、数値はバーチャルマシンで効率的に実装されていますが、\clsindmain{Number}の階層はSmalltalkクラス階層の他の部分と同じく、完全にアクセス可能で拡張可能です。

\begin{figure}[ht]
\centerline {\includegraphics[width=8cm]{NumberHierarchy}}
\caption{数値のクラス階層 \figlabel{numbers}}
\end{figure}

数値は\scatind{Kernel-Numbers}カテゴリの中にあります。この階層の抽象最上位クラスは\clsind{Magnitude}です。このクラスは比較演算子をサポートするあらゆるの種類のクラスを表します。\ct{Number}は、様々な算術演算子やその他の演算子を追加します。これらの演算子のほとんどが抽象メソッドです。\clsind{Float}と\clsind{Fraction}はそれぞれ浮動小数点数と分数を表します。\clsind{Integer}も抽象クラスで、サブクラス\clsind{SmallInteger}、\clsind{LargePositiveInteger}、\clsind{LargeNegativeInteger}に区分されます。ただし、必要に応じて自動的に値が変換されるので、ほとんどのユーザーは三つの\ct{Integer}クラスの違いについて気にする必要はありません。

%-----------------------------------------------------------------
\subsection{Magnitude}

\clsindmain{Magnitude}は\clsind{Number}の親であるだけでなく、\clsind{Character}、\clsind{Duration}、\clsind{Timespan}などのような比較演算をサポートするその他のクラスの親クラスでもあります(\clsind{Complex}は比較できません。したがって\clsind{Complex}は\clsind{Number}を継承していません\footnote{訳注：\ct{Complex}クラスは\pharo 1.3に存在しません})

\mthind{Magnitude}{<}と\mthind{Magnitude}{=}は抽象メソッドです。それ以外の演算子はジェネリックに((もっと良い言葉は無いか))定義されています。例えば:

\begin{method}{比較用の抽象メソッド}
Magnitude>>> < aMagnitude 
    "レシーバが引数よりも小さいかどうかを答える"
    ^self subclassResponsibility

Magnitude>>> > aMagnitude 
    "レシーバが引数よりも大きいかどうかを答える"
    ^aMagnitude < self
\end{method}
\cmindex{Magnitude}{>}

%-----------------------------------------------------------------
\subsection{Number}

同様に、\clsindmain{Number}では\mthind{Number}{+}、\mthind{Number}{-}、\mthind{Number}{*}、\mthind{Number}{/}などが抽象メソッドとして定義されており、それ以外の算術演算子はジェネリックに定義されています。

すべての\ct{Number}オブジェクトは、\mthind{Number}{asFloat}や\mthind{Number}{asInteger}のような様々な\emph{変換}演算子をサポートします。またそれ以外にもたくさんの\emphind{ショートカットコンストラクタメソッド}つまり、\ct{Number}を実部がゼロの\clsind{Complex}のインスタンスに変換する\mthind{Number}{i}や、\ct{Number}から\clsindplural{Duration}オブジェクトを生成する\mthind{Number}{hour}、\mthind{Number}{day}、\mthind{Number}{week}などがあります。

\ct{Numbers}は\mthind{Number}{sin}、\mthind{Number}{log}、\mthind{Number}{raiseTo:}、\mthind{Number}{squared}、\mthind{Number}{sqrt}などの良くある\emph{数学関数}を直接サポートしています。

\cmind{Number}{printOn:}は抽象メソッド\ct{Number>>>printOn:base:}(((The default base is 10.)))を使って実装されています。

\emph{testing}メソッドとしては\mthind{Number}{even}、\mthind{Number}{odd}、\mthind{Number}{positive}、\mthind{Number}{negative}などがあります。当然\ct{Number}は\lct{is\-Num\-ber}をオーバーライドしています。さらに興味深い点として、\mthind{Number}{isInfinite}は\ct{false}を返すように定義されています。

\emph{切り捨てと丸め((truncation and round off))}メソッドとしては\mthind{Number}{floor}、\mthind{Number}{ceiling}、\mthind{Number}{integerPart}、\mthind{Number}{fractionPart}などがあります。

\begin{code}{@TEST}
1 + 2.5     --> 3.5             "二つの数の和"
3.4 * 5      --> 17.0           "二つの数の積"
8 / 2         --> 4                 "二つの数の商"
10 - 8.3   --> 1.7              "二つの数の差\footnote{((listing 内に脚注))訳注：\pharo 1.3では表示が異なる場合があります}"
12 = 11    --> false           "二つの数の等価性"
12 ~= 11 --> true            "二つの数が異なるかどうかをテスト"
12 > 9      --> true            "より大きい"
12 >= 10  --> true            "以上"
12 < 10    --> false           "より小さい"
100@10   --> 100@10    "座標の生成"
\end{code}
\on{listingパッケージ内でタブがどう動作するかをチェックすること...}

次の例が\st では驚くほど正しく動作します:
\begin{code}{@TEST}
1000 factorial / 999 factorial --> 1000
\end{code}
\ct{1000 factorial}は他の多くの言語では計算するのが非常に難しいのですが、実際に計算できているという点に注目して下さい。これは自動変換と、数値の正確な処理の非常に良い例になっています。
\cmindex{Integer}{factorial}

\dothis{\ct{1000 factorial}の結果を表示してみましょう。計算よりも表示に長い時間がかかります!}

%-----------------------------------------------------------------
\subsection{Float}

\clsindmain{Float}は\ct{Number}の抽象メソッドに浮動小数点数用の実装を与えます((?Float implements the abstract Number methods for floating point numbers.))。

さらに興味深いことに、\ct{Float class}(\ie\ct{Float}のクラスボタン側((いいの?)))は次の\emph{定数}を返すメソッドを提供しています: \mthind{Float class}{e}、\mthind{Float class}{infinity}、\mthind{Float class}{nan}、\mthind{Float class}{pi}。

\begin{code}{@TEST}
Float pi                      --> 3.141592653589793
Float infinity               --> 無限大
Float infinity isInfinite --> true
\end{code}

%-----------------------------------------------------------------
\subsection{Fraction}

\clsind{Fraction}は、\ct{Integer}である分子と分母を表すインスタンス変数によって表されます。\ct{Fraction}は(\cmind{Fraction}{numerator:denominator:}というコンストラクタメソッドを使用するのではなく)通常は\ct{Integer}の割り算によって生成されます。

\begin{code}{@TEST}
6/8             --> (3/4)
(6/8) class --> Fraction
\end{code}

\ct{Fraction}と\ct{Integer}または他の\ct{Fraction}を掛け合わせると\ct{Integer}になることがあります:

\begin{code}{@TEST}
6/8 * 4 --> 3
\end{code}

\lr{分数の使用を避けるには演算数のいずれかを浮動小数点数にしなければいけないということについて触れるかもしれません。例、6.0 / 8 or 6 asFloat / 8. (p. 213)}

%-----------------------------------------------------------------
\subsection{Integer}

\clsindmain{Integer}は三つの具象整数クラスの実装の親に当たる抽象クラスです。多くの抽象的な\ct{Number}のメソッドの具体的な実装を提供するだけでなく、\mthind{Integer}{factorial}、\mthind{Integer}{atRandom}、\mthind{Integer}{isPrime}、\mthind{Integer}{gcd:}など、整数独自のメソッドも数多く追加されています。

\clsindmain{SmallInteger}は、インスタンスがコンパクトに表現できるという点で特殊です。つまり、\ct{SmallInteger}は値を参照として保持する代わりに、他の整数が参照を保持するために使用している領域を直接数値を表すために使用します。オブジェクト参照の最初のビットが、そのオブジェクトが\ct{SmallInteger}かどうかを示しています。

クラスメソッドである\mthind{SmallInteger}{minVal}と\mthind{SmallInteger}{maxVal}で、\ct{SmallInteger}の範囲が分かります:

\begin{code}{@TEST}
SmallInteger maxVal = ((2 raisedTo: 30) - 1)      --> true
SmallInteger minVal = (2 raisedTo: 30) negated --> true
\end{code}

\ct{SmallInteger}がその範囲に収まらなくなると、必要に応じて自動的に\clsind{LargePositiveInteger}または\clsind{LargeNegativeInteger}に変換されます:

\begin{code}{@TEST}
(SmallInteger maxVal + 1) class --> LargePositiveInteger
(SmallInteger minVal - 1) class  --> LargeNegativeInteger
\end{code}

大きな整数も同様に、適切なタイミングで小さな整数に変換されます。

多くのプログラミング言語と同じく、整数は繰り返しの振舞いを表すために利用できます。ブロックを繰り返し評価することに特化した\mthind{Integer}{timesRepeat:}というメソッドもあります。
\charef{syntax}で既に同様の例が出てきました:
\begin{code}{@TEST | n |}
n := 2.
3 timesRepeat: [ n := n*n ].
n --> 256
\end{code}

%=================================================================
\section{Character}

\clsindmain{Character}は\scatind{Collections-Strings}カテゴリで、\clsind{Magnitude}のサブクラスとして定義されています。\pharo 内で表示可能な文字は\lct{\$$\langle$\emph{char}$\rangle$}で表されます。例えば次のように成ります:

\begin{code}{@TEST}
$a < $b --> true
\end{code}

表示できない文字も様々なクラスメソッドを利用して生成できます。\mbox{\cmind{Character class}{value:}}はUnicode(またはASCII)を表す整数値を引数として受け取って、対応する文字を返します。\protind{accessing untypeable characters}プロトコルには、\mthind{Character class}{backspace}、\mthind{Character class}{cr}、\mthind{Character class}{escape}、\mthind{Character class}{euro}、\mthind{Character class}{space}、\mthind{Character class}{tab}などのたくさんの便利なコンストラクタメソッドが含まれています。

\begin{code}{@TEST}
Character space = (Character value: Character space asciiValue) --> true
\end{code}

\mthind{Character}{printOn:}メソッドは優秀なので、文字を生成する三つの方法の内で最も適切な表現がどれかを理解しています:

\begin{code}{@TEST}
Character value: 1   --> Character home
Character value: 2   --> Character value: 2
Character value: 32 --> Character space
Character value: 97 --> $a
\end{code}\ignoredollar$

次のような便利な\emph{testing}メソッドが数多く組み込まれています: \mthind{Character}{isAlphaNumeric}、\mthind{Character}{isCharacter}、\mthind{Character}{isDigit}、\mthind{Character}{isLowercase}、\mthind{Character}{isVowel}など。

\ct{Character}をその文字だけを含む文字列に変換するには、\mthind{Character}{asString}メッセージを送信します。この場合、\ct{asString}と\mthind{Character}{printString}は異なる結果を生じます。

\begin{code}{@TEST}
$a asString    --> 'a'
$a                  --> $a
$a printString --> '$a'
\end{code}

ASCIIの\ct{Character}はそれぞれ一意のインスタンスで、クラス変数である\cvind{CharacterTable}の中に保持されています:

\begin{code}{@TEST}
(Character value: 97) == $a --> true
\end{code}\ignoredollar$

しかし、0から255の範囲の外にある(非ASCIIの)\ct{Character}は一意ではありません:

\begin{code}{@TEST}
Character characterTable size                               --> 256
(Character value: 500) == (Character value: 500) --> false
\end{code}

%=================================================================
\section{String}

\clsindmain{String}クラスも\scatind{Collections-Strings}カテゴリで定義されています。\ct{String}は\ct{Character}だけを保持できる添字付きの\ct{Collection}です。

\begin{figure}[ht]
  {\centerline {\includegraphics[width=0.4\textwidth]{StringHierarchy}}}
\caption{文字列のクラス階層 \figlabel{strings}}
\end{figure}

実のところ、\ct{String}は抽象クラスで、\pharo の\ct{String}は実際には具象クラスである\clsindmain{ByteString}のインスタンスです。

\begin{code}{@TEST}
'hello world' class --> ByteString
\end{code}

\ct{String}のもう一つの重要なサブクラスは\clsindmain{Symbol}です。主な違いは、\ct{Symbol}には一つの値につきたった一つのインスタンスしか存在しないということです(これはしばしば「一意インスタンス性」と呼ばれます)。一方、別々に生成されたまたま同じ文字の並びを持つ\ct{String}は異なるオブジェクトであることもよくあります。

\begin{code}{@TEST}
'hel','lo' == 'hello' --> false
\end{code}

\begin{code}{@TEST}
('hel','lo') asSymbol == #hello --> true
\end{code}

\noindent
もう一つの重要な違いは、\ct{String}は変更可能ですが、\ct{Symbol}は変更不能ということです。

\begin{code}{@TEST}
'hello' at: 2 put: $u; yourself --> 'hullo'
\end{code}\ignoredollar$

\begin{code}{NB: CANNOT TEST}
#hello at: 2 put: $u --> エラー!
\end{code}\ignoredollar$

文字列はコレクションなので、他のコレクションと同様のメッセージを理解できるということは見落とされがちです:

\begin{code}{@TEST}
#hello indexOf: $o --> 5
\end{code}\ignoredollar$

\ct{String}は\clsind{Magnitude}を継承していませんが、\ct{<}, \ct{=}などの通常の\protind{comparing}メソッドをサポートしています。さらに、\cmind{String}{match:}はいくつかの基本的なglobスタイルのパターンマッチが使用できて便利です。

\begin{code}{@TEST}
'*or*' match: 'zorro' --> true
\end{code}

さらに進んだ正規表現のサポートが必要なときには、Vassili Bykovによる\pkgind{Regex}パッケージを参照してください。
\index{Bykov, Vassili}
\index{正規表現パッケージ}

文字列は比較的多くの変換メソッドをサポートしています。それらの多くは\mthind{String}{asDate}、\mthind{String}{asFileName}などのような、他のクラスの\ind{ショートカットコンストラクタメソッド}です。また、\mthind{String}{capitalized}や\mthind{String}{translateToLowercase}などのような、文字列から他の文字列に変換する便利なメソッドもたくさんあります。

文字列とコレクションについて更に進んだ話題は、\charef{collections}を参照して下さい。

\on{さらに利用できる資料がこちらにあります:
\url{http://www.dmu.com/crb/crb7.html}.}

%=================================================================
\section{Boolean}

\clsindmain{Boolean}クラスはSmalltalkという言語がどれほど多くのものをクラスライブラリに詰め込んでいるかということについて非常に興味深い洞察を与えてくれます。\ct{Boolean}は\patind{Singleton}クラスである\clsindmain{True}と\clsindmain{False}の\subind{クラス}{抽象}スーパークラスです。

\begin{figure}[ht]
  {\centerline {\includegraphics[width=0.5\textwidth]{BooleanHierarchy}}}
\caption{Booleanのクラス階層 \figlabel{booleans}}
\end{figure}

\ct{Boolean}の振る舞いのほとんどは引数として二つの\ct{Block}を取る\mthind{Boolean}{ifTrue:ifFalse:}を詳しく調べることで理解できるでしょう。

\begin{code}{@TEST}
(4 factorial > 20) ifTrue: [ 'bigger' ] ifFalse: [ 'smaller' ] --> 'bigger'
\end{code}

このメソッドは\ct{Boolean}の中では抽象メソッドです。
具象サブクラスでの実装はいずれも簡単なものです:

\begin{method}{\lct{ifTrue:ifFalse:}の実装}
True>>>ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
    ^trueAlternativeBlock value

False>>>ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
    ^falseAlternativeBlock value
\end{method}
\cmindex{True}{ifTrue:}
\cmindex{False}{ifTrue:}

実際、これこそがOOPの本質です。メッセージがオブジェクトに送られたら、オブジェクト自身がどのメソッドで反応するかを決めるのです。今回の場合では、\ct{True}インスタンスは\emph{true}の選択肢を実行し、反対に\ct{False}インスタンスは\emph{false}の選択肢を実行します。\ct{Boolean}のすべての抽象メソッドは、\ct{True}と\ct{False}の中でこのような方法で実装されています。例えば:

\begin{method}{否定の実装}
True>>>not
    "否定--レシーバがtrueなのでfalseを返します。"
    ^false
\end{method}
\cmindex{True}{not}

\ct{Boolean}には\mthind{Boolean}{ifTrue:}、\mthind{Boolean}{ifFalse:}、\mthind{Boolean}{ifFalse:ifTrue}などのような便利メソッドがいくつかあります。また強欲・怠惰な論理積・論理和から好きなものを選ぶことができます。

\begin{code}{@TEST}
(1>2) & (3<4)              --> false    "両者を必ず評価します"
(1>2) and: [ 3<4 ]        --> false    "レシーバだけが評価されます"
(1>2) and: [ (1/0) > 0 ] --> false    "引数ブロックは評価されないので、例外も発生しません"
\end{code}

最初の例では、\mthind{Boolean}{&}が\ct{Boolean}引数を受け取るので、\ct{Boolean}である部分式は両方とも評価されます。
二つ目と三つ目の例では、\mthind{Boolean}{and:}が引数として\ct{Block}を取るので、最初の式しか評価されません。\ct{Block}は最初の引数が\pvind{true}のときにだけ評価されるのです。

\dothis{\ct{and:}と\ct{or:}がどのように実装されているか想像してみてください。
そして\ct{Boolean}と\ct{True}と\ct{False}での実装を確認してみましょう。}

%=================================================================
\section{まとめ}

\begin{itemize}
%  \item Send \ct{yourself} to get back the receiver at the end of a cascade.

  \item もし\ct{=}をオーバーライドしたら、同時に\ct{hash}もオーバーライドする必要があります。

  \item 自作オブジェクトのコピーを正しく実装するには\ct{postCopy}をオーバーライドして下さい。

  \item ブレークポイントを設定するには\ct{self halt}を送信します。

  \item メソッドを抽象メソッドにするには\ct{self subclassResponsibility}を返します。

  \item オブジェクトの\ct{String}表現を提供するには、\ct{printOn:}をオーバーライドして下さい。

  \item インスタンスを適切に初期化するにはフックメソッドである\ct{initialize}をオーバーライドします。

  \item \ct{Number}の一連のメソッドは自動的に\ct{Float}、\ct{Fraction}、\ct{Integer}の間で変換されます。

  \item \ct{Fraction}は浮動小数点数ではなく本当の有理数を表しています。

  \item \ct{Character}のインスタンスは一意です。

  \item \ct{String}は変更可能ですが、\ct{Symbol}はそうではありません。
  しかし文字列リテラルは変更できないということに注意しましょう!

  \item \ct{Symbol}は一意ですが、\ct{String}はそうではありません。

  \item \ct{String}と\ct{Symbol}は\ct{Collection}なので、一般的な\ct{Collection}のメソッドをサポートしています。

\end{itemize}

%=============================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=============================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End: 

% $Author$
% $Date$
% $Revision$

% HISTORY:
% 2006-10-24 - Pollet started
% 2006-12-09 - Andrew adds material
% 2007-08-30 - Andrew completes first draft
% 2007-08-31 - Oscar edits
% 2007-09-07 - Stef corrections
% 2007-10-08 - Cassou corrections
% 2010-03-05 - Alexandre minor correction (thanks Ralph Boland)

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{\pharo のプログラミング環境}
\chalabel{env}

% Email 2009-10-21
\hw{The fist paragraph talks about error handling. Maybe it is a good idea to reference point 1.4 for the problems related with error handling. I know that forward references are not good, but changing the order to talk about error codes first is a big change. \\
Just as a comment, in my class of exceptions, I start talking about how to write safe code and talk about error code as a common technique. Then we discuss about the problems of error code handling (as you do later in the chapter) and then I make them think about how to "remove" all that code duplication... the solution then is obviuos, the problem needs to be reified and a object model has to be created to solve the problem... then we talk about whose responsible for what so, processes, contexts and blocks came into play and we deduce the final model together... Anyway, the idea of seen exceptions as a model that replaces error codes makes a lot of sense to them and help them understand exceptions from the conceptual point of view \\
- Section 1.4: it says: "If Smalltalk did provide exception-handling".
I think it should say: "If Smalltalk did NOT provide exception-handling" \\
- Something that is missing but I don't know if it is one goal of the chapter is some words about whose responsible to signal exceptions (the objects at the end of the tree call) and whose responsible to handle exceptions (the objects at the top of the tree call) \\
Section 1.7 sounded to me a little out of order... because you need to talk about defaultAction but you have not talked about how handlers are found yet... I would move this secction to the end, as an example of exception usage \\
- Page 12, point 4: it says: "send it value: E". I think it should say "send TO it value: E". I also would write "value: E" in italics because it makes more clear that you are talking about a message. \\
- Section Nested Exceptions: "Exception handlers are outside of their own scope" For me is confusing... maybe "Exception handlers do not handle exceptions signaled during its evaluation" or something like that?
The first example of Nested Exceptions does:
\ct{result := [[ Error signal ....]}\\
But nowhere before is said what \#on:do: returns...  \\
- Section 1.9: Does it make sense to talk about abandon? It is the same as return... 
Section 1.10: I would put section 1.10 as part of 1.9. I mean, it is the same from the organization point of view as Retry Execution, etc. \\
- Page 16, second example: ResumableLoader>>readOptionsFrom:aStrem. A the end of the method does "aStream close". I think it should not close the stream, that is responsibility of the one that opened it and passed it as parameter.
Page 16, third example, the "stream close" should be inside an \#ensure: :-) \\
- I would move the Deprication example to a different section. I think it is better to finish with how exception can be handle and then give examples. \\
- About deprication, why is it an exception? why not having a global object to wich one can send the message \#deprecated:on:in: ? my feeling is that there is no need to use exceptions for this... even more, I'm starting to think that they are a bad example of exception usage... \\
- Section 1.11: I would move it inside section 1.9, at the same level as Retry excecution, Returning execution, etc.
Section 1.12: Same as section 1.11. I would put Resending exceptions as part of 1.9
Section 1.13: Same as section 1.11 (does it make sense to have outer? I think it only adds confusion... just a coment) \\
- Page 23: It seems to me that the second example is not doing what it is expected. The handler variable references the doit closure, not the handler. I think it should be:
\ct{| exception handler |
[ exception := thisContext sender at: 1. 
1/0 ]
on: Error
do: [ :ex | handler := thisContext ].
{ exception . handler } explore}
I would also suggest to send the message \#at: 1 to the handler \\
- Section 1.16: I don't like the title... Specialized Exceptions or Specific Exceptions ?
I think a good discussion about when to subclass an exception and when to reuse an exception is valuable. Something to help avoid a class explosion of exceptions... That is an interesting problem... \\
}

この章の目的は、\pharo のプログラミング環境を使い、どのようにプログラムを開発するかを示すことです。
既にブラウザを使ってメソッドやクラスをどのように定義するかについて見てきたわけですが、この章ではブラウザのその他の機能について示し、他のいくつかのブラウザについて紹介していきます。

もちろん作ったプログラムが期待したように動作しないのはよくあることです。\pharo には優れたデバッガがあります。もっとも役立つツールではありますが、最初に使うときは悩むかも知れません。デバッグのセッションで練習し*、デバッガの幾つかの機能について実演します。

\st 固有の特徴の1つは、プログラミングをしているとき、静止したプログラムテキストの世界ではなく、生きているオブジェクトからなる世界にいるということです。このことにより、プログラミングの間に非常に素早いフィードバックを得ることが可能で、このフィードバックによって生産性がより向上します。生きているオブジェクトを見たり、実際に変更するために2つのツールがあります。それは\emph{インスペクタ}と\emph{エクスプロア}です。

ファイルやテキストエディタではなく、生きているオブジェクトからなる世界でのプログラミングの結果、\st イメージファイルからプログラムを取り出すために、何らかの明示的な作業をしなければいけません。
この作業のための昔からのやり方は、\emph{ファイルアウト}や\emph{チェンジセット}を作ることで、全ての\st の方言でサポートされています。これらは、基本的に他のシステムで読み込めるようにコード化されたテキストファイルです。
\pharo 上でプログラムを取り出すための新しい方法は、サーバー上のバージョン管理されたリポジトリにコードをアップロードすることです。このために、Monticelloと呼ばれるツールを使い、特にチームで作業する際に、よりパワフルで効果的な手段となります。
\seeindex{change set}{file, filing out}
\index{file!filing out}

%Finally, you may find a bug in \pharo as you work; we explain how to report bugs, and how to submit bug fixes.
%\ab{Or I would, if I knew how.   We should do this, or remove the paragraph.}

%=========================================================
\section{概要}
\seclabel{overview}

\st と現在のグラフィカルインターフェースは一緒に発展してきました。
\st の最初の公開リリースである1983年以前でさえ、\st は独自のグラフィカルな開発環境を提供していました。そして全ての\st の開発はその上で行われてきました。
では、\pharo の主なツールを見ていきましょう。

\begin{itemize}
	\item{\menu{Browser}(ブラウザ)}は、中心的な開発ツールです。クラスやメソッドの作成、定義、構築を行う際にこのツールを使います。これを使うことで全てのクラスライブラリも閲覧できます。ソースコードを別々のファイルに保存する他の環境とは異なり、\st では全てのクラスやメソッドがイメージファイルに含まれます。
	\index{browser}

	\item{\menu{Message Names}(メッセージネーム)}ツールを使うことにより、特定のセレクタもしくは部分文字列を含んだセレクタを持つ全てのメソッドを探すことができます。(訳注：Pharo 1.3ではFinderツールに統合されており、ドロップダウンメニューでSelectorsを選択することで利用できます)
	\index{message name finder}
	
	\item{\menu{Method Finder}(メソッド・ファインダ)}ツールは、メソッドを探すのに役立ちますが、??誤訳??何と呼ばれるのかと同様に何を\emph{する}のかによりメソッドを検索します。(訳注：Pharo 1.3ではFinderツールに統合されており、ドロップダウンメニューでExamplesを選択することで利用できます)
	\index{method finder}
	
	\item{\menu{Monticello Browser}(Monticelloブラウザ)}は、Monticelloパッケージからコードを読み込んだり、保存したりするための出発点です。
	
	\item{\menu{Process Browser}(プロセスブラウザ)}は、\st 上で実行されている全てのプロセス(スレッド)を見るのに役立ちます。
	\index{process browser}
	
	\item{\menu{Test Runner}}は、SUnitテストを実行、デバッグすることができます。詳細については\charef{SUnit}を参照して下さい。
	\index{Test Runner}
	\index{SUnit}
	
	\item{\menu{Transcript}(トランスクリプト)}は、\glbind{Transcript}出力ストリームに対するウィンドウで、\secref{transcript}で既に述べた通り、ログメッセージを書くのに役立ちます。
	
	\item{\menu{Workspace}(ワークスペース)}は入力することができるウィンドウです。
          これは色々な目的に使えますが、最もよく使われるのは\st 式を入力して、\menu{do it}で実行することです。
          \ind{workspace}の使い方は\secref{transcript}にも図解されています。
\end{itemize}

\menu{Debugger}(デバッガ)は名前からわかる通り明確な役割を持っています。しかし、他のプログラミング言語のデバッガも比べて、より重要な役割を担っていることに気づくでしょう。\st では\ind{debugger}上で\emph{プログラム}できるのです。デバッガはメニュー画面から起動されるのではなく、たいてい、失敗するテストプログラムを実行したり、\short{\textbf{.}}と入力することにより起動しているプロセスを中断したり、あるいは、コード中に\lct{self halt}式を挿入することで、起動されます。
\index{process!interrupting}

%=========================================================
\section{ブラウザ}
\seclabel{browser}

\st の歴史と共に、長年にわたり多くの異なるクラスブラウザが開発されてきました。
\pharo では、様々なビューを1つにまとめたブラウザを提供することで、この物語を単純にしました。
\figref{SystemBrowser0}は最初にブラウザを開いたときに表示されるものです。\footnote{もしブラザウが\figref{classBrowser}のように表示されない場合、デフォルトのブラウザを変更する必要があるかも知れないことを思い出して下さい。\faqref{packagebrowser}参照}\footnote{訳注：\Pharoのデフォルトブラウザは何度も変更されています。バージョン1.3では、OBSystemBrowserが使用されており、この章の説明とは異なる場合があります。}

\begin{figure}[htbp]
   \centering
   \ifluluelse
	 {\includegraphics[width=\textwidth]{SystemBrowser0} }
	 {\includegraphics[width=0.7\textwidth]{SystemBrowser0} }
   \caption{ブラウザ}
   \figlabel{SystemBrowser0}
\end{figure}

ブラウザ上部の4つの小さなペインは、システム内メソッドの階層ビューを表しています。これは、NeXTstepの\textit{File Viewer}やMac OS Xの\textit{Finder}のカラムモードといった、ディスク上のファイルを見るためのビューと同様のものです。
左端のペインはクラスの\emph{パッケージ}リストです。その内の1つ(例えば\scat{Kernel})を選択すると、すぐ右隣にあるペインにパッケージ中のすべてのクラスが表示されます。
% \on{I adopted the spelling of NeXTstep recommended by wikipedia}

\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics[width=\textwidth]{SystemBrowser1} }
	   {\includegraphics[width=.7\textwidth]{SystemBrowser1} }
   \caption{ブラウザで\ct{Model}クラスを選択
   \figlabel{SystemBrowserModel}}
\end{figure}

同様に、左から2番目のペインでクラスの1つ、例えば\menu{Model}(\figref{SystemBrowserModel}参照)を選ぶと、その右隣の3番目のペインにクラスに対して定義された\emph{プロトコル}が表示され、デフォルトで仮想プロトコル\prot{-{}-all-{}-}が選択されます。
プロトコルとはメソッドをカテゴリー化するためのもので、クラスの振る舞いを概念的に首尾一貫して細分化することで、それらを探したり考えたりするのに役立ちます。
左から4つめのペインは、選択したプロトコルで定義されている全てのメソッド名が表示されます。
ここでメソッド名を選ぶと、そのメソッドのソースコードがブラウザ下部にある大きなペインに表示されます。このペインではソースコードの閲覧や編集、編集後の保存ができます。
ブラウザで\menu{Model}クラス、\protind{dependents}プロトコル、そして\menu{myDependents}を選択していくと、\figref{SystemBrowserMyDependents}のように表示されるはずです。
\protindex{all}
\cmindex{Model}{myDependents}

\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics[width=\textwidth]{SystemBrowserMyDependents}}
	   {\includegraphics[width=0.7\textwidth]{SystemBrowserMyDependents}}
   \caption{\ct{Model}クラスの\ct{myDependents}メソッドをブラウザで表示
   \figlabel{SystemBrowserMyDependents}}
\end{figure}

Mac OS X の\emph{Finder}とは違い、ブラウザ上部4つのペインは完全に同じものというわけではありません。
クラスやメソッドは\st 言語の一部であるのに対し、パッケージとプロトコルはそうではなく、これらはブラウザの各ペインに表示すべき情報量を制限するために導入されたものです。たとえば、もしプロトコルがなければ、ブラウザは選択したクラスの全てのメソッドのリストを表示する必要があります。多くのクラスでは、このようなリストは大きすぎて扱うのが不便になってしまいます。
\index{Mac OS X Finder}

このことから、新しいパッケージやプロトコルを作る方法は、新しいクラスやメソッドを作る方法とは異なります。新しいパッケージを作るにはパッケージペインで\actclick し\menu{new package}を選びます。新しいプロトコルを作るにはプロトコルペインで\actclick し\menu{new protocol}を選びます。
ダイアログの中に新しく作ったものの名前を入力すれば完了です。パッケージやプロトコルについては、名前や内容を入力する以外に必要な作業は何もありません。
\index{package!creating}

\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics[width=\textwidth]{SystemBrowserClassCreation}}
	   {\includegraphics[width=0.7\textwidth]{SystemBrowserClassCreation}}
   \caption{クラス作成テンプレートをブラウザに表示
   \figlabel{SystemBrowserClassCreation}}
\end{figure}

これとは対照的に、新しいクラスやメソッドを作るには、
実際に何らかの\st コードを書く必要があります。
(左端のペインで)現在選択されているパッケージをクリックすると、
ブラウザ下部のペインにクラス生成のテンプレートが表示されます(\figref{SystemBrowserClassCreation})。
このテンプレートを編集することで、新しいクラスを作ります。
\ct{Object}を作りたいサブクラスの親となる既存のクラス名で置き換え、
\ct{NameOfSubclass}を新しいサブクラス名に置き換えます。
既にわかっているのであれば、インスタンス変数名を入力します。
新しいクラスに対するカテゴリーは、デフォルトで現在選択しているパッケージのカテゴリーとなりますが、
\footnote{パッケージとカテゴリーが正確には同じものではないことを思い出して下さい。\secref{packages}にてそれらの関係について詳しく見ていきます}必要なら変更することもできます。
既にサブクラス化の元となる既存クラスをブラウザで選択しているのならば、
クラスペインを\actclick し\menu{class templates \ldots \go subclass template}を選択することにより、
ほんの少し初期化が異なる同様のテンプレートを得ることができます。
また、既存のクラス定義でクラス名を新しいものに変えることでもクラス定義を編集できます。
どの場合でも新しい定義をアクセプトすると、
(\ct{#}から始まる名前の)新しいクラスが(つまり対応するメタクラスのインスタンスが)作られます。
クラスを作ることはそのクラスを参照するグローバル変数を作ることでもあるため、
名前によって既存の全クラスを参照することができるわけです。


\index{class!creation}
\index{browser!defining a class}

新しいクラス名が、(\ie \ct{#}で始まる)\lclsind{シンボル}としてクラスの作ったテンプレートの中に現れる理由や、クラスが作られた後は(\ie \ct{#}のない)識別子としてクラス名を使えば、そのクラスをコードから参照できるようになる理由が理解できたでしょうか?

新しいメソッドを作るプロセスも同様です。最初にメソッドを作りたいクラスを選択し、次にプロトコルを選択します。\figref{SystemBrowserMethodTemplate}のように、ブラウザは編集可能なメソッド作成テンプレートを表示します。
\index{method!creation}
\index{browser!defining a method}

\begin{figure}[htbp]
   \centering
   \ifluluelse
	   {\includegraphics [width=\textwidth]{SystemBrowserMethodTemplate}}
	   {\includegraphics[width=0.7\textwidth]{SystemBrowserMethodTemplate}}
   \caption{メソッド作成テンプレートをブラウザに表示
   \figlabel{SystemBrowserMethodTemplate}}
\end{figure}

%---------------------------------------------------------
\subsection{コード空間を渡り歩く}

ブラウザはコードを探したり分析するためのいくつかのツールを提供します。
これらのツールは、様々なコンテキストメニューを\actclick したり、あるいは最も頻繁に使われるツールなどはキーボードショートカットによって利用できます。

\subsubsection{新しいブラウザウインドウを開く}
\seclabel{browsing}

時折、複数のブラウザウインドウを開きたくなる場合があります。
コードを書いているときは少なくとも2つ必要でしょう。1つは入力中のメソッドのため、もう1つは物事がどう動いているのか調べるのにシステム周りを見るためです。
テキスト中でクラス名を選択した後に\ind{キーボードショートカット}\short{b}を使えば、そのクラスを表示するブラウザを起動することができます。
\index{browser!browse button}
\index{keyboard shortcut!browse it}

\dothis{次のことを試してみてください: ワークスペースウインドウ内でクラス名(たとえば\ct{Morph})を入力し、それを選択し\short{b}を押して下さい。この方法はよく役に立ち、どのテキストウィンドウでも使えます。}

\subsubsection{メッセージのセンダとインプリメンタ}
\seclabel{sendersImplementors}

\index{browser!senders}
メソッドペインで\menu{browse \ldots \go senders (n)}を\actclick すると、選択したメソッドを使用している全てのメソッドのリストが表示されます。ブラウザを開いて\ct{Morph}を選択した後、メソッドペインの中の\mthind{Morph}{drawOn:}メソッドをクリックすると、\ct{drawOn:}本体がブラウザ下部に表示されます。 \menu{senders (n)} (\figref{SendersOfDrawOn})を選ぶと、\ct{drawOn:}を一番上の項目としたメニューが現れ、以下\ct{drawOn:}が送る全てのメッセージ(\figref{SendersOfDrawOn2})が順に表示されます。このメニューの項目を選ぶと、選択したメッセージ(\figref{CanvasDraw})を送る仮想イメージ内の全メソッドのリストがブラウザで表示されます。

%\begin{figure}[htb]
%\begin{minipage}[b]{0.74\textwidth}
%\centerline {\includegraphics[width=\textwidth]{SendersOfDrawOn}}
%\caption{The \menu{senders (n)} menu item.\figlabel{SendersOfDrawOn}}
%\end{minipage}
%\hfill
%\begin{minipage}[b]{0.24\textwidth}
%\centerline {\includegraphics[width=\textwidth]{SendersOfDrawOn2}}
%\caption{Choose senders of which message.\figlabel{SendersOfDrawOn2}}
%\end{minipage}
%\end{figure}

\begin{figure}[htb]
\centerline {\includegraphics[width=\textwidth]{SendersOfDrawOn}}
\caption{\menu{senders (n)}メニュー項目。\figlabel{SendersOfDrawOn}}
\end{figure}

\begin{figure}[htb]
\centerline {\includegraphics[width=0.4\textwidth]{SendersOfDrawOn2}}
\caption{メッセージのセンダを選択。\figlabel{SendersOfDrawOn2}}
\end{figure}

\menu{senders (n)}の中の``n''は、メッセージのセンダを探すためのキーボードショートカットが\short{n}であることを示しています。この方法は、\emph{どの}テキストウインドウでも使えます。

\dothis{コードペインにあるテキスト``drawOn:''を選択して\short{n}を押せば、直ちに\ct{drawOn:}のセンダが表示されます。}

\begin{figure}[htbp]
	\begin{center}
   \ifluluelse
		{\includegraphics[width=\textwidth]{CanvasDraw}}
		{\includegraphics[width=0.7\textwidth]{CanvasDraw}}
	\end{center}
	\caption{センダブラウザは \ct{Canvas>>>draw}メソッドが、引数に対して\ct{drawOn:}メッセージを送っていることを表しています。\figlabel{CanvasDraw}}
\end{figure}

\ct{AtomMorph>>>drawOn:}にある\ct{drawOn:}のセンダを探せば、それがsuper \subind{super}{send}であることがわかるでしょう。つまり、実行されるメソッドは\ct{AtomMorph}のスーパークラスにあることがわかります。ではいったいどのクラスでしょうか? \menu{browse \go hierarchy implementors}を\actclick すれば、そのメソッドが\ct{EllipseMorph}クラスにあることがわかります。 
\index{browser!hierarchy button}

\figref{CanvasDraw}のリストの6番目にあるセンダ\ct{Canvas>>>draw}を見てみましょう。
このメソッドは、引数として渡されたどんなオブジェクトに対しても\ct{drawOn:}を送ることがわかります。つまり、あらゆるクラスのインスタンスが引数となる可能性があります。
データフロー解析がいくつかのメッセージのレシーバクラスを把握する助けにはなりますが、一般的には、ブラウザを使ってもどのメッセージ送信がどのメソッドの実行につながるのかを知る簡単な方法はありません。
このような理由から``センダ'' ブラウザは、メッセージが示唆するメソッドだけ、つまり選択されたセレクタを持つ全てのメッセージセンダを表示します。
それにも関わらず、どのようにメソッドを\emph{使う}のかを理解する必要があるときには、すぐに使用例を導けるのでセンダブラウザが大いに役立ちます。
同じセレクタを持つ全てのメソッドは同じように使われるはずなので、メッセージの使い方はどれも似ているはずです。
\index{browser!senders}

\index{browser!implementors}
インプリメンタブラウザも似たような動作をしますが、メッセージセンダのリストの代わりに、同じセレクターを持つメソッドを実装している全クラスのリストを表示します。
このことを確かめるために、メソッドペインにある\lct{drawOn:}を選び、\menu{browse \go implementors (m)}を選びます(もしくはコードペイン中のテキスト``drawOn:''を選択し、\short{m}を押します)。すると、\ct{drawOn:}メソッドを実装する90余りのクラスが、スクロール可能なメソッドリストのウインドウとして表示されます。
これほど多くのクラスがこのメソッドを実装していることに驚く必要はありません。\ct{drawOn:}は、画面上に自分自身を描画することができる全てのオブジェクトによって理解されるメッセージなのです。

\subsubsection{メソッドのバージョン}
\seclabel{versions}

新しい\subind{method}{バージョン}のメソッドを保存しても、古いものは失われません。\pharo は全ての古いバージョンを保存し、異なるバージョンを比較したり、古いバージョンに戻したり(``復帰'')することができます。
\begin{figure}[btp]
   \centering
   \includegraphics[width=\textwidth]{Versions}
   \caption{\ind{バージョンブラウザ}が2つの\ct{TheWorldMenu>>>buildWorldMenu:}メソッドを表示}
   \figlabel{buildWorldMenuVersions}
\end{figure}
\menu{browse \go versions (v)}メニュー項目により、選択したメソッドに加えられた一連の変更を調べることができます。
\figref{buildWorldMenuVersions}では、\ct{buildWorldMenu:}メソッドの2つのバージョンを示しています。

\index{browser!versions button}
上部のペインには、そのメソッドのバージョン毎に1行ずつ表示されており、このメソッドを書いたプログラマのイニシャル、保存した日時、クラスとメソッドの名前、そして定義されているプロトコルが表示されます。現在の(アクティブな)バージョンはリストの一番上にあります。選択されたバージョンは、下部のペインに表示されます。
% If the \menu{diffs} checkbox is selected, as it is in \figref{mouseUpVersions}, the display also shows the differences between the selected version and the one immediately older. 
選択されたメソッドと現在のバージョンの違いを表示したり、選択したバージョンに復帰するためのボタンが用意されています。
% The \menu{prettyDiffs} checkbox is useful if there have been changes to layout: it pretty-prints both versions before differencing, so that the differences that are displayed exclude formatting changes. 

\ind{バージョンブラウザ}の存在は、必要なコードを残すべきか悩む必要がなく、単に削除すれば良いことを意味しています。もしそのコードが\emph{本当に}必要だと分かったら、いつでも古いバージョンに復帰することができますし、古いバージョンから必要なコードの断片を得て別のメソッドに貼り付けることもできます。
バージョンブラウザを使う癖を付けましょう。もはや必要のなくなったコードをコメントアウトするのは悪い習慣です。なぜなら、そのことで現在のコードが読みにくくなるからです。
Smalltalkerは読みやすいコードを非常に高く評価します。

\hint{メソッド全体を削除した後で、元に戻したい場合はどうすればいいでしょう? チェンジセットの中に削除したものを見つけることができます。そこで\actclick することにより、以前のバージョンを確認できます。
チェンジセットブラウザは\secref{env:changeSet}で述べられています。}

\subsubsection{メソッドのオーバーライド}
\seclabel{overriding}

インヘリタンスブラウザは、表示されたメソッドによってオーバーライドされた全てのメソッドを表示します。
どのように動作するかを見るために、ブラウザで\cmind{ImageMorph}{drawOn:}メソッドを選択してください。
(\figref{OBinheritanceBrowser})メソッド名の隣にある三角形のアイコンに注目してください。
上向きの三角形は、\ct{ImageMorph>>>drawOn:}が継承されたメソッド(\ie \ct{Morph>>>drawOn:})をオーバーライドしていることを示しており、さらに下向きの三角形は、サブクラスによってオーバーライドされていることを示しています。(アイコンをクリックすることで、これらのメソッドに移動することもできます。)
ここで、\menu{browse \go inheritance}を選択してください。
インヘリタンスブラウザが、オーバーライドされたメソッドの階層関係を示します。(\figref{OBinheritanceBrowser}参照)

\begin{figure}[btp]
	\begin{center}
   \ifluluelse
		{\includegraphics[width=\textwidth]{OBInheritanceOverriding}}
		{\includegraphics[width=0.7\textwidth]{OBInheritanceOverriding}}
	\end{center}
	\caption{\ct{ImageMorph>>>drawOn:} とそれがオーバーライドしたメソッド。選択したメソッドの兄弟関係がリストに表示されている。}
	\figlabel{OBinheritanceBrowser}
\end{figure}

\subsubsection{階層ビュー}
\seclabel{hierarchy}

標準では、ブラウザは左端のペインにパッケージのリストを表示します。
しかしクラスの階層ビューに切り替えることは可能です。
関心のある特定のクラスを選択してください。例えば\ct{ImageMorph}を選択し、\button{hier.}ボタンをクリックします。
選択したクラスの全てのスーパークラスとサブクラスを含むクラス階層を、左端のペインで見ることができます。
２つ目のペインは選択したクラスのメソッドを実装するパッケージのリストが表示されます。\footnote{訳注：バージョン1.3では階層ブラウザが表示されますが、２つ目のペインにパッケージのリストは表示されません}
%The \button{hierarchy} button opens a \ind{hierarchy browser} on the current class; this
%browser can also be opened by using the \menu{browse hierarchy} menu item in the class pane.
%The hierarchy browser is similar to the browser, but instead of displaying the categories and the classes in each category, it shows a single list of classes, indented to represent inheritance.
%The category of the selected class is displayed in the small annotation pane at the top of the browser.
\figref{hierarchyBrowser}では、\clsind{ImageMorph}のスーパークラスが \clsind{Morph}であることを階層ブラウザが示しています。
\index{browser!hierarchy button}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{hierarchyBrowser}}
		{\includegraphics[width=0.7\textwidth]{hierarchyBrowser}}
	\end{center}
	\caption{\ct{ImageMorph}の階層ビュー}
	\figlabel{hierarchyBrowser}
\end{figure}

\subsubsection{変数への参照を見つける}
\seclabel{variables}

\index{browser!variables}
クラスペインにあるクラスを\actclick し、\menu{browse \go chase variables}を選択することで、インスタンス変数やクラス変数が使われている場所を見つけることができます。
\emph{追跡ブラウザ}を使うことで、全てのインスタンス変数やクラス変数のアクセサ、更にこれらのアクセサを送るメソッドなどを探索することができます(\figref{chasingBrowser})。

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{chasingBrowser}}
		{\includegraphics[width=0.7\textwidth]{chasingBrowser}}
	\end{center}
	\caption{\ct{Morph}に対する追跡ブラウザ}
	\figlabel{chasingBrowser}
\end{figure}

% The menu also includes \menu{inst var defs}, which shows the subset of the instance variable references that assign to the variable. 
%Once you click on the button or select the menu item, you will be presented with a dialog that invites you to choose a variable from all of the variables defined in the current class, and all of the variables that it inherits.  The list is in inheritance order; it can often be useful to bring up this list just to remind yourself of the name of an instance variable.  If you click outside the list, it will go away and no variable browser will be created.

%Also available by \actclick{ing} the class pane is \menu{class vars}, which opens an inspector showing the class variables of the current class \emph{and their values}, and \menu{class refs (N)} which displays a list of all of the methods that directly reference the current class.

\subsubsection{ソース}
\seclabel{sources}

\index{browser!view}
メソッドペインを\actclick することで利用可能となる\menu{various \go view \ldots}メニュー項目は、``how to show''メニューを表示しますが\footnote{訳注：バージョン1.3ではメソッドペインの下にあるViewボタンを押すと``Choose''メニューが表示されます}、これは選択されたメソッドをソースペインでブラウザがどのように表示するかを選ばせるものです。 \menu{source}（ソースコード）、\menu{prettyPrint}（整形されたソースコード）、\menu{byteCode}（バイトコード）および\menu{decompile}（バイトコードから逆コンパイルされたソースコード）といった選択肢があります。
% The label on the button changes if you select one of the other modes.  There are other options too; if you let the mouse linger over the names, a help balloon will appear.  Try some of them.
\index{method!pretty-print}
\index{method!decompile}
\index{method!byte code}

``how to show''メニューで選択した\menu{prettyPrint}は、ソースを保存する前に整形出力したメソッドと同じもの\footnote{\menu{pretty print (r)}はメソッドペインの最初のメニュー項目もしくはコードペインの真ん中下側にあります。}\footnote{訳注：バージョン1.3では、メソッドペインおよびコードペインでの整形出力機能はありません。}ではないことに注意してください。
このメニューは、ブラウザの表示方法を制御するだけで、システムに格納されたコードには何の影響も及ぼしません。
2つのブラウザを開いて一方のブラウザで\menu{prettyPrint}を選び、もう一方のBrowserで\menu{source}を選ぶことで、このことを確認できます。
実際、2つのブラウザで同じメソッドを表示させた状態で、一方で\menu{byteCode}を選択し、もう一方で\menu{decompile}選択することは、\pharo の仮想マシンのバイトコードの命令セットについて学ぶ良い方法です。

\subsubsection{リファクタリング}

コンテキストメニューから多くの標準的なリファクタリングが行えます。
4つのペインのどれでも\actclick すれば、現在リファクタリング可能な操作を見ることができます。
\figref{refactoring}を参照してください。

以前は、リファクタリングのためにリファクタリングブラウザと呼ばれる特殊なブラウザを使う必要がありましたが、現在はどのブラウザからも利用できます。

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{refactoring}}
		{\includegraphics[width=0.7\textwidth]{refactoring}}
	\end{center}
	\caption{リファクタリング操作}
	\figlabel{refactoring}
\end{figure}

%---------------------------------------------------------
\subsection{ブラウザのメニュー}

ブラウザのペインを\actclick することで多くの追加機能を利用することができます。
たとえメニュー項目上のラベルが同じであっても、その\emph{意味}は文脈に依存します。
例えばパッケージペイン、クラスペイン、プロトコルペイン、そしてメソッドペインの全てが\menu{File out}メニュー項目を持っています。しかしそれらは異なる動作をします。パッケージペインの\menu{File out}メニューは、パッケージ全体をファイル出力します。クラスペインの\menu{File out}メニューはクラス全体をファイル出力します。プロトコルペインの\menu{File out}メニューはプロトコル全体をファイル出力します。そしてメソッドペインの\menu{File out}メニューは表示されたメソッドだけをファイル出力します。
このことは明らかだと思えるかもしれませんが、初心者にとっては混乱の元になります。
\index{file!filing in}
\index{file!filing out}

おそらくパッケージペインの中で最も便利なメニュー項目は\menu{find class\ldots (f)}です。カテゴリーは活発に開発しているコードについては役立ちますが、ほとんど誰もシステム全体のカテゴリー化について知りませんし、クラスがどのパッケージにあるか推測するよりも、クラス名の先頭の数文字を入力した後でshort{f}と入力した方がずっと早いのです。\menu{recent classes\ldots}はたとえクラス名を忘れてしまっても、最近ブラウズしたクラスへ素早く戻るのに役立ちます。
\index{class!finding}
\index{class!recent}

ブラウザの左上にある検索ボックスに名前を入力することで、特定のクラスやメソッドを探すこともできます。リターンキーを入力するとシステムに問い合わせがなされ、その結果が表示されます。検索語の前に\ct{#}を付けることで、クラスへの参照や、メッセージのセンダを探せることに気をつけてください。
%To browse to a particular method, you can 
%In the class pane, there are two menu items \menu{find method} and \menu{find method wildcard\ldots} that can be useful if you want to browse a particular method.  
選択したクラスの特定のメソッドを探すのであれば、(デフォルトで表示される)\prot{-{}-all-{}-}プロトコルをブラウズした方が速いでしょう。メソッドペインにマウスを移動し、探そうとしているメソッド名の最初の文字を入力してください。
メソッドペインがスクロールして、探しているメソッド名が見えるでしょう。
\index{method!finding}
\protindex{all}

\dothis{\cmind{OrderedCollection}{removeAt:}で2つの操作方法を試してください。}

メニューには他の多くのオプションがあります。これを使うことで、ブラウザ上の作業やどこに何があるかを探すための時間を数分減らすことができます。？？？？

\dothis{クラスペインメニューの\menu{Browse Protocol}, \menu{Browse Hierarchy}, そして\menu{Show Hierarchy}の結果を比較してください。}

%---------------------------------------------------------
\subsection{プログラムによるブラウズ}

\glbind{SystemNavigation}クラスはシステム周りを操作するために役に立つユーティリティメソッドのいくつかを提供しています。
典型的なブラウザが提供する機能の大半は、\ct{SystemNavigation}によって実装されています。
\index{browsing programmatically}

\dothis{
\ct{drawOn:}:のセンダを見るためには、ワークスペースを開いて以下のコードを評価してください。}
\begin{code}{}
SystemNavigation default browseAllCallsOn: #drawOn:
\end{code}
センダの検索を特定のクラスのメソッドに制限するには以下のようにします。
\begin{code}{}
SystemNavigation default browseAllCallsOn: #drawOn: from: ImageMorph
\end{code}
開発ツールもオブジェクトなので、プログラムから完全にアクセス可能であり、自分自身のツールを開発することや既存のツールを必要に応じて変更することもできます。

\menu{implementors}メニュー項目と等価なプログラムは以下のようなものです。
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #drawOn:
\end{code}

他に何が出来るのかを知るには、ブラウザで\ct{SystemNavigation}クラスを探してください。
更なる操作例については、FAQ(\appref{faq})で見つけることができます。

%=========================================================
\section{Monticello}

\secref{Monticello}において、\pharo のパッケージ作成ツールである\ind{Monticello}の概要について説明しました。
しかし、Monticelloは、その章で述べたこと以上の特徴を備えています。
Monticelloは\emph{パッケージ}を扱うので、Monticelloについて説明する前に、まず\ind{パッケージ}が何なのかということを正確に説明する必要があります。

%---------------------------------------------------------
\subsection{パッケージ: \pharo コードの宣言的なカテゴリー化}\seclabel{packages}

かなり前の\secref{categoriesPackages}において、パッケージとは概ねカテゴリーと同等のものであると指摘しました。ここでは、その関係が実際には何であるか見ていきます。
パッケージシステムとは、\st ソースコードを組織化するためのシンプルで軽量な方法のことです。これは、カテゴリーとプロトコルに対して簡単な命名規則を利用します。

例を使って説明しましょう。
あるフレームワークを開発していると仮定しましょう。これは \pharo から関係データベースを簡単に利用するためのものです。あなたはこのフレームワークを\ct{PharoLink}と呼ぶことにしました。そして、作成したクラスを全てを含むような一連のカテゴリーを作ったとします。例えば、
\ct{'PharoLink-Connections'}カテゴリーは\ct{OracleConnection MySQLConnection PostgresConnection}を含み、\ct{'PharoLink-Model'}カテゴリーは\ct{DBTable DBRow DBQuery}等を含みます。しかし、作成したコードの全てがこれらのクラスの中にあるわけではありません。例えば、オブジェクトをSQL的な形式に変換するための一連のメソッドもあるかもしれません。

\begin{code}{}
Object>>>asSQL
String>>>asSQL
Date>>>asSQL
\end{code}

\noindent
これらのメソッドは、
% \damien{don't we say 'belong to'?}
% \on{no -- belong in = they should be there; belong to = they are there}
\ct{PharoLink-Connections}や\ct{PharoLink-Model}カテゴリと同じパッケージに属しています。
しかし、明らかに\ct{Object}クラス全体がそのパッケージに属するわけではありません。
つまり、クラスの残りが別のパッケージにあるとしても、特定の\emph{メソッド}をパッケージに含める方法が必要になります。

\index{package!extension}
\seeindex{extension package}{package, extension}

それを行う方法は、(\ct{Object}, \ct{String} \ct{Date}等)のメソッドを、prot{*PharoLink}(最初のアスタリスクに注意してください)というプロトコルに置くことです。\scat{PharoLink-\ldots}カテゴリーと\prot{*PharoLink}プロトコルの組み合わせが、\ct{PharoLink}パッケージを形作ります。
正確には、パッケージに置かれる規則は以下の通りです。

\ct{Foo}と名付けられたパッケージは次のものを含みます。

\begin{enumerate}		\seclabel{packageRules}
	\item{} \scat{Foo}カテゴリもしくは\scat{Foo-}で始まる名前のカテゴリ内にある、クラスの全ての\emph{クラス定義}
	\item{} \label{env:extensions} \prot{*Foo}や\prot{*foo}\footnote{比較の際に大文字か小文字かは無視されます。}という名前のプロトコルか、\prot{*Foo-}や\prot{*foo-}で始まる名前のプロトコルにある、\emph{任意のクラス}内の全ての\emph{メソッド}
	\item{} \scat{Foo}カテゴリーか、\scat{Foo-}で始まる名前のカテゴリーのクラスにある全ての\emph{メソッド}。ただし\prot{*}で始まる名前のプロトコルにあるメソッドは\emph{除外される}。
	
\end{enumerate}
\noindent
これらの規則の結果、各クラスの定義と各メソッドが、ちょうど1つのパッケージに属することになります。最後の規則にある\emph{例外}は、それらのメソッドが他のパッケージに属すために必要となります。規則\ref{env:extensions}にある、大文字小文字が無視されるというのは、カテゴリ名がキャメルケース（空白を含まない）のに対して、（必ずという訳ではないが）典型的なプロトコル名が小文字である（空白を含む場合がある）からです。
\index{camelCase}

\ct{PackageInfo}クラスがこれらの規則を実装しており、このクラスを試すことで規則の感触をつかむことができます。

\dothis{ワークスペース上で以下の式を評価して下さい。}

\begin{code}{}
mc := PackageInfo named: 'Monticello'
\end{code}

さて、このパッケージについて探索できるようになりました。
例えば、ワークスペース上で\ct{mc classes}を表示することで、Monticelloパッケージを構成するクラスの長いリストが得られます。
\ct{mc coreMethods}
は、これらのクラスにある全てのメソッドに対する\ct{MethodReference}のリストが返されます。\ct{mc extensionMethods}は、おそらく最も面白い問い合わせでしょう。この問い合わせは、\ct{Monticello}パッケージに含まれる全てのメソッドのうち、\lct{Monticello}クラスを除いたものを返します。

パッケージは比較的新しく\pharo に加えられたものです。しかし、パッケージの命名規則は、すでに使われていたものをベースとしていたため、パッケージの採用を意識していない古いコードを分析する際にも\ct{PackageInfo}を使うことができます。

\dothis{\ct{(PackageInfo named: 'Collections') externalSubclasses}を\lct{表示}してください。この式は、\ct{Collection}パッケージに\emph{含まれていない}\ct{Collections}の全てのサブクラスの一覧を返します。}

%---------------------------------------------------------
\subsection{Monticelloの基礎}

\ind{Monticello}は、合衆国3番目の大統領であり「信教の自由を求めたバージニアの法」の作者であるトーマス・ジェファーソンの山頂の家にちなんで名付けられました。この名前はイタリア語で``小さな山''を意味し、イタリア語の``c''をchairの``ch''と発音して「モンティチェロ」と言います。


\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{freshMonticello}}
		{\includegraphics[width=0.7\textwidth]{freshMonticello}}
	\end{center}
	\caption{Monticelloブラウザ}
	\figlabel{freshMonticello}
\end{figure}

Monticelloブラウザを開くと、\figref{freshMonticello}のように、2つのペインと1列に並んだボタンが表示されます。
左側のペインには、実行中の仮想イメージにロードされた全てのパッケージが表示され、名前の後のカッコの中にはパッケージを特定するバージョンが表示されます。

右側のペインには、Monticelloが知っている全てのソースコードリポジトリが表示されており、通常はそれらのリポジトリからコードがロードされます。左側のペインにあるパッケージを選ぶと、右側のペインには、選択したパッケージのバージョンを含むリポジトリのみを表示するようにフィルタリングされます。

リポジトリの1つは\emph{package-cache}と呼ばれるディレクトリで、実行中のイメージファイルのあるディレクトリのサブディレクトリです。
遠隔地にあるリポジトリからコードを読み込んだり、書き込んだりする場合、コピーがpackage-cacheにも保存されます。ネットワークが利用できない場合にパッケージへアクセスする必要のあるとき、package-cacheが役立ちます。また、例えば電子メールの添付ファイルとしてMonticelloファイル(.mcz)が直接与えられた場合、そのファイルをpackage-cacheディレクトリに置くのが一番手軽なアクセス方法となります。
\index{package!cache}

リストに新しいリポジトリを追加するには、\button{+Repository}ボタンをクリックし、ポップアップメニューからリポジトリの種類を選んでください。ではHTTPリポジトリを追加しましょう。

\dothis{Monticelloを開き、\button{+Repository}ボタンをクリックし、\menu{HTTP}を選びます。
以下のようにダイアログ内容を編集してください。}
%\ab{How does one continue the $\backslash$dothis to include the code?}
%\on{Don't.  Just close the \dothis{} and follow with the code.}
\needlines{4}
\begin{code}{}
MCHttpRepository
	location: 'http://squeaksource.com/PharoByExample'
	user: ''
	password: ''
\end{code}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=0.7\textwidth]{SqueakSource-PBE}}
		{\includegraphics[width=0.7\textwidth]{SqueakSource-PBE}}
	\end{center}
	\caption{リポジトリブラウザ}
	\figlabel{SqueakSource:PBE}
\end{figure}
\noindent
その後、このリポジトリをリポジトリブラウザで開く為に、\button{Open}ボタンをクリックします。\figref{SqueakSource:PBE}のようなものが見えるでしょう。左側のペインには、リポジトリ内の全てのパッケージのリストがあります。その中の1つを選択すれば、右側のペインにこのリポジトリ内にある選択されたパッケージの全てのバージョンが表示されます。

その中の1つのバージョンを選択すると、\button{Browse}ボタンでの(イメージファイルに読み込むことなしに)閲覧や\button{Load}ボタンでの読み込み、そして、\button{Changes}ボタンでは、選択したバージョンを読み込んだ場合の変更点を見ることができます。\button{Copy}ボタンでは、任意のバージョンのパッケージのコピーを作成して、他のリポジトリに書きこむこともできます。

見ればわかるとおり、バージョン名には、パッケージ名、バージョン作成者のイニシャル、およびバージョン番号が含まれています。バージョン名はリポジトリ内のファイル名でもあります。これらの名前を変更してはいけません。なぜならMonticelloの適切な操作は、これらの名前に依存しているからです! Monticelloのバージョンファイルは単なるzipアーカイブであり、興味があればzipツールを使ってファイルを解凍できますが、その内容を見る最良の方法は、Monticello自体を使うことです。

Monticelloでパッケージを作成するには、2つのことを行う必要があります。1つはコードを書くこと、もう1つはそれをMonticelloに伝えることです。

\dothis{\scat{PBE-Monticello}というパッケージを作成し、\figref{MCnewcategory}のように2つのクラスをその中に置いて下さい。もちろん、\ct{Object}などの既存のクラスのメソッドを作り、\pageref{sec:packageRules}ページにある規則を使ってこのクラスと同じパッケージに置いて下さい\,---\,\figref{MCnewmethod}を参照のこと。}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{MCnewcategory}}
		{\includegraphics[width=0.7\textwidth]{MCnewcategory}}
	\end{center}
	\caption{``PBE''パッケージの2つのクラス。}
	\figlabel{MCnewcategory}
\end{figure}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{MCnewmethod}}
		{\includegraphics[width=0.7\textwidth]{MCnewmethod}}
	\end{center}
	\caption{``PBE''パッケージに置かれる拡張メソッド。}
	\figlabel{MCnewmethod}
\end{figure}

作成したパッケージをMonticelloに伝えるために、\button{+Package}ボタンをクリックし、パッケージ名、この場合は``PBE''を入力して下さい。Monticelloは\ct{PBE}をパッケージリストに加えます。パッケージエントリはアスタリスクでマークされ、仮想イメージ内のバージョンがどのリポジトリにも書き込まれていないことを示します。ここで、Monticelloに2つのパッケージを持つことに注意して下さい。1つは\ct{PBE}、もう1つは\ct{PBE-Monticello}です。\ct{PBE}は\ct{PBE-Monticello}や\ct{PBE-}で始まる他の全てのパッケージを含むため、これで良いのです。

最初はこのパッケージに関連している唯一のリポジトリは、\figref{MC+PBE}に示されているようにパッケージキャッシュだけです。それで問題なく、コードを保存することができますし、パッケージキャッシュに格納されます。
\button{Save}ボタンをクリックすると、\figref{PBE-on}のように保存するパッケージのバージョンに対するログメッセージを入力するよう求められます。このメッセージをアクセプトするとMonticelloはパッケージを保存します。
保存したことを示すため、Monticelloのパッケージペインに付けられていたアスタリスクがなくなり、バージョン番号が付与されます。

もしパッケージに変更を加えた\,---\, 例えばクラスの1つにメソッドを追加した \,---\, 場合、アスタリスクが再び現れて、変更が保存されていないことを示します。パッケージキャッシュをリポジトリブラウザで開いて保存したバージョンを選べば、\button{Changes}ボタンや他のボタンを使うことができます。
もちろんリポジトリに新しいバージョンを保存することもできます。\button{Refresh}ボタンを押してリポジトリビューを一度更新すれば、\figref{package-cache-browser}のように表示されるはずです。
\index{package!cache}

\begin{figure}[tbp]
	\begin{center}
		\includegraphics[width=\textwidth]{MC+PBE}
	\end{center}
	\caption{Monticelloでまだ保存されていないPBEパッケージ。}
	\figlabel{MC+PBE}
\end{figure}

\begin{figure}[tbp]
	\begin{center}
	\includegraphics[width=0.8\textwidth]{PBE-on}
	\end{center}
	\caption{パッケージの新バージョンに対するログメッセージを入力する。}
	\figlabel{PBE-on}
\end{figure}

\begin{figure}[tbp]
	\begin{center}
	\includegraphics[width=\textwidth]{package-cache-browser}
	\end{center}
	\caption{作成したパッケージの２つのバージョンがパッケージキャッシュにあります。}
	\figlabel{package-cache-browser}
\end{figure}

新しいパッケージをパッケージキャッシュ以外のリポジトリに保存するためには、必要に応じてリポジトリを追加するなどして、まずMonticelloにそのリポジトリについて知らせる必要があります。
その後、パッケージキャッシュ上のリポジトリブラウザで\button{Copy}ボタンを使って、コピー先のリポジトリを選ぶことができます。
\figref{associateRepository}のようにリポジトリ上で\actclick し、\menu{add to package \ldots}を選ぶことで、お望みのリポジトリをパッケージと関連づけることもできます。
いったんパッケージがリポジトリに関連付いていれば、Monticelloブラウザでリポジトリとパッケージを選んで\button{Save}ボタンをクリックすることで、新しいバージョンを保存することができます。
もちろんリポジトリへ書き込むためのパーミッションは必要です。
\emphind{\sqsrc}上の\ct{PharoByExample}リポジトリは世界から読むことができますが、書き込むことはできません。そこに保存しようとしてもエラーメッセージが表示されるでしょう。
しかし、\sqsrc にあなた専用のリポジトリを作成することは可能です。\url{http://www.squeaksource.com}にあるWebインターフェースを使って、あなたのパッケージを保存するリポジトリを利用できます。
これは、友人とコードを共有したり複数のコンピュータを使う場合などの仕組みとして特に有用です。

\begin{figure}[tbp]
	\begin{center}
		\includegraphics[width=\textwidth]{MCaddToPackage}
	\end{center}
	\caption{パッケージに関連付けられたポジトリのセットにリポジトリに追加する。}
	\figlabel{associateRepository}
\end{figure}

書き込みパーミッションを持たないリポジトリに対して保存しようとした場合、ともかくそのバージョンはパッケージキャッシュに書き込まれます。
つまり、リポジトリの情報を編集するか(Monticelloブラウザで\actclick )別のリポジトリを選んで、パッケージキャッシュブラウザから\button{Copy}ボタンを押せば、そのバージョンを復活させることができます。

%=========================================================
\section{インスペクタと[Explore]}
\seclabel{inspector} % (fold)

\st が他の多くの言語と異なる特徴の一つは、静的なコードの世界ではなく、生きたオブジェクトの世界へ開かれた窓を提供しているということです。
そこではどのようなオブジェクトでもプログラマーによって調べることが可能です。さらには変更することさえできます。\,---\, ただし、システムを構成している基本的なオブジェクトを変更するような時には注意が必要です。
もちろん言うまでもなく、まず最初にイメージを保存しておいてください！

%---------------------------------------------------------
\subsection{インスペクタ}

\dothis{\ind{インスペクタ}を使ってどんなことが出来るか、実際に見てみるためにワークスペースで \ct{TimeStamp now} と入力し、\actclick で \menu{inpect it} を選んでください。}
(メニューを使う前にテキストを選択しておく必要はありません。テキストが選択されていない場合には、メニュー操作は現在の行全てを対象にするからです。
\menu{\textbf{i}nspect it} を選ぶ代わりに \short{i} とタイプしても同じです)
\clsindex{TimeStamp}
\index{keyboard shortcut!inspect it}

\begin{figure}[btp]
	\begin{center}
		\includegraphics[width=\textwidth]{inspectTimeNow1}
	\end{center}
	\caption{ \ct{TimeStamp now} をインスペクトする}
	\figlabel{inspectTimeNow1}
\end{figure}

\figref{inspectTimeNow1} のようなウィンドウが現れます。
これがインスペクタで、特定のオブジェクトの内部に向かって開かれた窓と考えることができます。特定のオブジェクトとは、 \,---\, この場合、 \ct{TimeStamp now} という式を評価することによって生成された \mbox{\ct{TimeStamp}} のインスタンスオブジェクトのことです。
% the \mbox is here because without it, the listings macros puts a space between TimeStamp 
% and the following word, and that space happens to come out at the start of a line.

ウィンドウのタイトルバーには、インスペクトしているオブジェクトが印字形式で表示されています。
左側のペインの先頭の \menu{self} を選択すると、右側のペインにそのオブジェクトが文字列で表示されます。
% If you select \menu{all inst vars} in the left pane, the right pane will show a list of the instance variables in the object, and the printstring for each one.  
% The remaining items in the left pane represent the instance variables; this makes it easy to examine them one at a time, and also to change them.
左側のペインはそのオブジェクトのツリー構造ビューとなっており、\self をツリーの根としています。
インスタンス変数は、名前の横にある三角形を展開することで探求できます。

インスペクタの下部にある横長のペインは小さなワークスペースウインドウです。このウィンドウでは、疑似変数の \ct{self} が左側のペインで選択したオブジェクトに束縛されているので便利です。
そこで、
\begin{code}{}
self - TimeStamp today
\end{code}
上記の式をワークスペースペインで \menu{inspect it} すると、結果は \clsind{Duration} オブジェクトになります。このオブジェクトは、今日の午前０時と \ct{TimeStamp now} を評価して得られた \ct{TimeStamp} オブジェクト（インスペクトしているもの）との、時間間隔を表しています。
さらに \ct{TimeStamp now - self} を評価すれば、あなたがこのセクションを読むのに費やした時間を教えてくれるでしょう！

\ct{self} だけでなく、オブジェクトの全てのインスタンス変数も、ワークスペースペインの有効範囲にあります。つまり、変数に対して式で参照したり代入することもできます。例えば、左のペインのツリーの根にあるオブジェクトを選んでから、ワークスペースペインで \ct{jdn := jdn - 1} を評価すると、インスタンス変数 \ct{jdn} の値が実際に変化することが分かりますし、\ct{TimeStamp now - self} の値も1日分増えるでしょう。

% ON: Does not work anymore
%You can change instance variables directly by selecting them, replacing the old value in the right-hand  pane by a \pharo expression, and accepting.  
%\pharo will evaluate the expression and assign the result to the instance variable.

DictionaryやOrderedCollectionやCompiledMethod、さらにいくつかのクラスに対しては、インスペクタに特別な拡張がなされていて、これらのオブジェクトの内容をより簡単に検査することができます。

%---------------------------------------------------------
\subsection{オブジェクトエクスプローラ}

\emph{オブジェクトエクスプローラ}は概念的にはインスペクタとよく似ていますが、情報の表し方が異なっています。
この相違点を調べるために、先ほどまでインスペクトしていたものと同じオブジェクトを\emph{エクスプローラ}で探求してみましょう。

\begin{figure}[tbp]
\begin{minipage}{0.48\textwidth}
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{exploreTimeStampNow}}
		{\includegraphics[width=0.7\textwidth]{exploreTimeStampNow}}
	\end{center}
	\caption{ \ct{TimeStamp now} を探求する}
	\figlabel{exploreTimeStampNow}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{exploreTimeStampNow2}}
		{\includegraphics[width=0.7\textwidth]{exploreTimeStampNow2}}
	\end{center}
	\caption{インスタンス変数を探求する}
	\figlabel{exploreTimeStampNow2}
\end{minipage}
\end{figure}

\dothis{インスペクタの左側のペインで \menu{self} を選び、\actclick で \menu{explore (I)} を選んでください}
\ind{エクスプローラ}ウインドウは \figref{exploreTimeStampNow} のように表示されます。
ツリー構造の \lct{根} の隣にある小さな三角形をクリックすると、ビューが \figref{exploreTimeStampNow2} のように変化します。このビューは、エクスプロアの対象とするオブジェクトのインスタンス変数を表示します。
\ct{offset} の隣の三角形をクリックすると、 \emph{その}インスタンス変数が見えます。
エクスプローラーは、複雑な階層構造を探求しなければならない場合に便利なため、この名前が付けられています。
\index{keyboard shortcut!explore it}

オブジェクトエクスプローラのワークスペースペインの働きは、インスペクタのものと若干異なります。
\ct{self} は必ずしもツリー構造の根にあたるオブジェクトではなく、現在選択されているオブジェクトに束縛されるようになっています。また、選択されたオブジェクトのインスタンス変数も同様のスコープに従っています。

エクスプローラの真価を見るために、深い入れ子構造をもったオブジェクトを調べてみましょう。

\dothis{ワークスペースで \ct{Object explore} を評価してください}
これは \pharo の \ct{Object} クラスを表すオブジェクトです。
メソッド辞書を表すオブジェクトに加えて、そのクラスのコンパイル済みメソッドも直接ナビゲート出来ることに注意してください（ \figref{ExploreObject} 参照）。

\begin{figure}[tbp]
	\begin{center}
		\includegraphics[width=0.5\textwidth]{ExploreObject}
	\end{center}
	\caption{\ct{Object} クラスを探求する}
	\figlabel{ExploreObject}
\end{figure}

%\dothis{Open a browser, and \metaclick five times on the method pane to bring-up the Morphic halo on the \ct{OBPluggableListMorph} that is used to represent the list of messages. 
%Click on the \emph{debug} handle \debugHandle{} and select \menu{explore morph}
%from the menu that appears.  This will open an Explorer on the \clsind{OBPluggableListMorph} object that represents the method list on the screen.  
%Open the root object (by clicking in its triangle), open its \ct{submorphs}, and continue exploring the structure of the objects that underlie this Morph, as shown in \figref{explorePluggableListMorph}.}
%
%\begin{figure}[tbp]
%	\begin{center}
%		\includegraphics[width=0.7\textwidth]{explorePluggableListMorph}
%	\end{center}
%	\caption{Exploring a \ct{PluggableListMorph}}
%	\figlabel{explorePluggableListMorph}
%\end{figure}

%=========================================================
\section{デバッガ}
\seclabel{debugger} % (fold)

\ind{デバッガ} は間違いなく \pharo のツールの中で一番強力なツールです。ただデバッグのためというだけでなく、新しいコードを書くのにも利用されます。
デバッガのデモンストレーションをするために、バグを作るところから始めましょう！

\dothis{ブラウザを使って、以下のメソッドを \ct{String} クラスに追加してください}

\needlines{7}
\begin{method}[buggy]{バグがあるメソッド}
suffix
	"自分自身をファイル名と仮定して、最後のドットから後ろの部分をサフィックスとして返す"
	| dot dotPosition |
	dot := FileDirectory dot.
	dotPosition := (self size to: 1 by: -1) detect: [ :i | (self at: i) = dot ].
	^ self copyFrom: dotPosition to: self size 
\end{method}

もちろん、こんな簡単なメソッドは動くのが当たり前だろうと確信するので、SUnit のテストも書かずにワークスペースで \ct{'readme.txt' suffix} と入力し、
\menu{print it(p)} を実行します。
すると驚くことに、期待した答え \ct{'txt'} の代わりに、 \figref{PreDebugWindow} のような \clsind{PreDebugWindow} がポップアップします。

\begin{figure}[btp]
	\begin{center}
	\includegraphics[width=0.8\textwidth]{PreDebugWindow}
	\end{center}
	\caption{ \ct{PreDebugWindow} によるバグの通知}
	\figlabel{PreDebugWindow}
\end{figure}

\ct{PreDebugWindow} はどんなエラーが起きたのかタイトルバーで分かるようになっています。さらに、エラーに至るまでのメッセージの \emphind{スタックトレース} が表示されます。
トレースの一番下を起点とし、 \ct{UndefinedObject>>DoIt} という行が、ワークスペースで \ct{'readme.txt' suffix} を選び、\pharo に \menu{print it} させた時のコンパイルおよび実行されたコードを表しています。
もちろん、このコードは \clsind{ByteString} クラスのオブジェクト(\ct{'readme.txt'})にメッセージ \ct{suffix} を送ります。
これは \ct{String} クラスから継承している \ct{suffix} メソッドの実行を引き起こし、このことがスタックトレースの次の行で \ct{ByteString(String)>>suffix} として表されています。
スタックをさらに辿ると、\ct{suffix} メソッドは \ct{detect:}\ldots メッセージを送信し、更に \ct{detect:ifNone:} メソッドで \ct{errorNotFound} を送信していることが分かります。
\clsindex{UndefinedObject}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{debuggerDetectIfNone}}
		{\includegraphics[width=0.7\textwidth]{debuggerDetectIfNone}}
	\end{center}
	\caption{デバッガ}
	\figlabel{debuggerDetectIfNone}
\end{figure}

\emph{なぜ}ドットが見つからなかったのかを調べるために、デバッガ本体が必要なので、\button{Debug} ボタンをクリックします。

%\dothis{You can also open the debugger by clicking on any of the lines on the stack trace.  If you do this, the debugger will open already focussed on the corresponding method.}

\figref{debuggerDetectIfNone} にデバッガを示します。最初は威嚇的に見えますが、使うのはとても簡単です。
タイトルバーと一番上のペインは \lct{PreDebugWindow} にあるものととてもよく似ています。
しかし、デバッガではスタックトレースはメソッドブラウザと合体させており、スタックトレース上の行を選択すると対応するメソッドが下のペインに表示されます。
エラーを引き起こした実行はまだイメージ内にありますが、中断状態にあることを意識することは重要です。
スタックトレースの各行は、実行を継続するのに必要な全ての情報を持った実行スタック上のフレームを表しています。これには、計算に伴う全てのオブジェクトと各インスタンス変数、実行中のメソッドの全ての一時変数も含まれています。

\figref{debuggerDetectIfNone} では、一番上のペインで \ct{detect:ifNone:} メソッドが選択されています。
メソッドの本体は中央のペインに表示されています。\ct{value} メッセージが青くハイライトされているのは、このメソッドではメッセージ \ct{value} を送信し、その結果を待っている状態であることを示しています。

デバッガの一番下の4つのペインは、実際には(ワークスペースペインを持たない)2つの小さなインスペクタです。
左側のインスペクタは現在のオブジェクト、つまり、中央のペインで \self に相当するオブジェクトを表しています。
別のスタックフレームを選ぶと、\self の示すオブジェクトが変わり、
\self{}-インスペクタの内容も変わります。
左下のペインの \self をクリックすると、\self がIntervalオブジェクト \ct{(10 to: 1 by -1)} であることが分かります。これは期待通りのオブジェクトです。
デバッガの小さなインスペクタにワークスペースペインは必要ありません。というのも、全ての変数がメソッドペインの有効範囲内にあるからです。このペインに対する式の入力や選択、それらの式の評価など自由に行うことができます。
そうした変更は、いつでも \menu{cancel(l)} メニューや \short{\textit{l}} を使って取り消せます。
% apb: that lower-case-L is in italics so that it doesn't look like a 1 or a |
\index{keyboard shortcut!cancel}

右側のインスペクタには、現在のコンテクストにおける一時変数が表示されます。
\figref{debuggerDetectIfNone} では、
\ct{value} が、引数 \ct{exceptionBlock} に送られています。

%\dothis{To see the current value of this parameter, click on \ct{exceptionBlock} in the context inspector.
%This will tell you that \ct{exceptionBlock} is \ct{[self errorNotFound: ...]}.
%\on{no longer true!}

スタックトレースで一つ下のメソッドを見ると、\ct{exceptionBlock} は \ct{[self errorNotFound: ...]} です。エラーメッセージが表示されるのは驚くことではありません。

ちなみに、ミニインスペクタに表示された変数に対して完全なインスペクタやエクスプローラを開きたい場合は、単に変数名をダブルクリックするか、変数名を選んで \actclick し、\menu{inspect(i)} もしくは \menu{explore(I)} を選びます。
こうしておくと、他のコードの実行中に変数の変化を見たい場合に便利です。
\index{keyboard shortcut!inspect it}
\index{keyboard shortcut!explore it}

メソッドウィンドウに戻って見てみると、メソッドの最後から２番目の行で、文字列 \ct{'readme.txt'} から \lct{ドット} を見つけようとしており、その実行が目的の行に達していないことがわかります。
\pharo は逆向きに実行させることは出来ませんが、メソッドを再実行させることは可能で、オブジェクト自体を変化させず、新しいオブジェクトを生成するようなコードの場合にうまく働きます。

\dothis{\button{Restart} をクリックしてください。すると実行位置が現在のメソッドの最初の文に戻ります。
次に送信されるメッセージ {\ct{do:}} が青くハイライトして表示されています( \figref{RestartDetectIfNone} 参照)。}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{RestartDetectIfNone}}
		{\includegraphics[width=0.7\textwidth]{RestartDetectIfNone}}
	\end{center}
	\caption{\ct{detect: ifNone:} メソッドを再実行した後のデバッガ}
	\figlabel{RestartDetectIfNone}
\end{figure}

\button{Into} と \button{Over} ボタンは2つの異なる方法でステップ実行します。\button{Over} ボタンを押した場合、\pharo は現在のメッセージ送信(この場合では \ct{do:})を、エラーが発生しない限り1ステップだけ実行します。
つまり \button{Over} ボタンによって、現在のメソッドの次のメッセージ送信へと移ります。この場合は \ct{value} となります。\,---\, これは、まさしく最初にいた場所なので、大した助けにはなりません。
必要なことは、なぜ \ct{do:} メソッドが求めている文字を見つけられないのかをつきとめることです。

\dothis{\button{Over} ボタンをクリックした後で、\button{Restart} ボタンをクリックして \figref{RestartDetectIfNone} の状態に戻ってください。}

\dothis{\button{Into} ボタンをクリックしてください。\pharo はハイライトされていたメッセージ送信に対応するメソッドの中に入ります。この場合は、\ct{Collection>>do:} です。}

しかし、どちらにしてもこれはあまり助けにならないことが分かります。というのも \ct{Collection>>do:} が壊れていないことはかなり確信が持てます。\pharo に対して \emph{何かを} させているところにバグがあるはずです。
この場合、\button{Through} ボタンを用いるのが適しています。\ct{do:} メソッド自身の詳細を無視して、引数ブロックの実行に焦点を当てたいからです。

\dothis{再度 \ct{detect:ifNone:} メソッドを選び、\button{Restart} ボタンで \figref{RestartDetectIfNone} の状態に戻します。
今度は \button{Through} ボタンを数回クリックします。このとき、コンテクストウィンドウの \ct{each} 変数を選択しておきます。
\ct{do:} メソッドの実行に従って、\ct{each} の内容が \ct{10} からカウントダウンしていくことが分かります。}

\ct{each} の値が \ct{7} の時、\ct{ifTrue:} ブロックを実行することが期待されますが、しかし、そうなりません。
何が悪いのかを見るため、\figref{steppingIntoValue} で示すように \ct{value:} を \button{Into} ボタンでステップ実行します。

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{steppingIntoValue}}
		{\includegraphics[width=0.7\textwidth]{steppingIntoValue}}
	\end{center}
	\caption{\ct{do:} メソッドを数回 \lct{Through} ボタンでステップ実行した後のデバッガ}
	\figlabel{steppingIntoValue}
\end{figure}

\button{Into} ボタンをクリックした後、\figref{dotIsAString} で示した位置にいることがわかります。
一見すると \ct{suffix} メソッドに \emph{戻って} しまったように見えますが、\ct{suffix} メソッドが \ct{detect:} メソッドに引数として渡しているブロックを実行中なのです。
%\on{does not work any more! the debugger does not know about block variables!}
%If you select \ct{i} in the context inspector, you can see its current value, which should be \ct{7} if you have been following along.  
%You can then select the corresponding element of \self from the \self{}-inspector.
%In  \figref{dotIsAString} you can see that element \ct{7} of the string is character 46, which is indeed a dot.
コンテクストインスペクタで \ct{dot} を選ぶと、その値が \ct{'.'} であることが分かります。
ここに至って、なぜイコールとならなかったかわかりました。\ct{'readme.txt'} の7番目の文字は \ct{Character} なのに、\ct{dot} が \ct{String} となっています。

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{dotIsAString}}
		{\includegraphics[width=0.7\textwidth]{dotIsAString}}
	\end{center}
	\caption{\ct{'readme.txt' at: 7} が \ct{dot} と等しくならない原因を示しているデバッガ}
	\figlabel{dotIsAString}
\end{figure}

バグが判明したので修正方法も明白です。\ct{dot}を探す前に、文字へ変換する必要があります。

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{revertDialog}}
		{\includegraphics[width=0.7\textwidth]{revertDialog}}
	\end{center}
	\caption{デバッガの中で \ct{suffix} メソッドを修正する。内側のブロックから抜けだすかどうかの確認}
	\figlabel{revertDialog}
\end{figure}

\dothis{\ct{dot := FileDirectory dot first} のように、デバッガの中でコードを正しく修正し、変更を \menu{accept} してください。}

\lct{detect:} の内側にあるブロック内のコードを実行しているため、この修正によっていくつかのスタックフレームが失われることになります。それでよいかどうかを \pharo が確認します( \figref{revertDialog} 参照)、\menu{yes} をクリックして、新しいメソッドを保存(およびコンパイル)します。

%\dothis{Click \button{Restart} and then \button{Proceed}; the debugger window will vanish, and the evaluation of the expression \ct{'readme.txt' suffix} will complete, and print the answer \ct{'.txt'}}

\ct{'readme.txt' suffix} 式の評価は完了し、\ct{'.txt'} という答えを出力します。

この答えは正しいでしょうか？残念ながら、明確には述べられません。サフィックスは \ct{.txt} であるべきでしょうか？それとも \ct{txt} ？
\ct{suffix} メソッドのコメントが、全然明確ではありません。
こうした問題を避ける方法は、答えを定義する \ind{SUnit} テストを書くことです。

\begin{method}[testSuffix]{\ct{suffix} メソッドのための簡単なテスト}
testSuffixFound
	self assert: 'readme.txt' suffix = 'txt'
\end{method}

テストの記述に必要な労力は、ワークスペースで同じテストを実行するよりも若干多いですが、\sunit を使うことで、テストを実行可能な文書として保持し、他人が簡単にテストできるようになります。
さらに、\ct{StringTest} クラスに \mthref{testSuffix} を追加して \sunit でテストを実行すれば、エラーのデバッグに素早く戻ることができます。
\sunit はアサーション違反があるとデバッガを開きますが、\figref{fixOffByOne} のように、スタックフレームを１つ遡り、\button{Restart} ボタンでテストを再実行し、\button{Into} ボタンで \ct{suffix} メソッドに入ることでエラーを修正できます。
その後、\sunit Test Runner で \button{Run Failures} ボタンをクリックして、テストが通過することを確認するだけです。

\begin{figure}[btp]
	\begin{center}
		\includegraphics[width=\textwidth]{fixOffByOne}
	\end{center}
	\caption{デバッガの中で \ct{suffix} メソッドを編集する: \sunit のアサーション違反の後にOff-by-one エラーを修正する}
	\figlabel{fixOffByOne}
\end{figure}

以下はより良いテストコードです。

\begin{method}[testSuffix2]{\ct{suffix} メソッドのためのより良いテスト}
testSuffixFound
	self assert: 'readme.txt' suffix = 'txt'.
	self assert: 'read.me.txt' suffix = 'txt'
\end{method}
\noindent
どうしてこのテストがより良いものなのでしょう？その理由は、もし対象となる文字列に一つ以上のドットがある場合に、このメソッドがどうすべきであるかを読む人に教えてくれているからです。

なお、エラーを補足したり表明違反の発生以外に、デバッガに入るいくつかの方法があります。
コードを実行したら無限ループに入ってしまった場合、 \short{.} (英語を知ってれば分かりますが、終止符もしくはピリオド)と打ち込むことで割り込みをかけてその計算状況でのデバッガを開くことができます。\footnote{同様に、どんな時にでも \short{{\sc shift--}.} とタイプすると緊急デバッガが起動することを覚えておくと便利です。}
また、疑わしいコードの箇所に \ct{self halt} と入れておくだけでもいいです。
例えば、\ct{suffix} メソッドであるならば、次のような感じです。
\index{process!interrupting}

\needspace{11ex}
\begin{method}[suffix]{\ct{suffix} メソッドに \ct{halt} を入れる}
suffix
	"ファイル名と仮定して、最後のドットから後の部分をサフィックスとして返す。"
        	| dot dotPosition |
	dot := FileDirectory dot first.
	dotPosition := (self size to: 1 by: -1) detect: [ :i | (self at: i) = dot ].
	self halt.
	^ self copyFrom: dotPosition to: self size 
\end{method}

このメソッドを走らせると、 \ct{self halt} の実行により \ind{pre-debugger} が開いてきますので、そこで、実行を続行したり、デバッガに入って変数を見たり、ステップ実行したりコードを編集したりすることができます。

デバッガについては以上で全てですが、 \ct{suffix} メソッドについてはまだです。
最初のバグで気付いたかもしれませんが、対象となる文字列にドットがない場合、\ct{suffix} メソッドはエラーを発生します。
これは望ましい振る舞いではありませんので、こうしたケースでは何が起きるのか特定するために第2のテストを追加してみます。

\needlines{3}
\begin{method}[testNoSuffix]{\ct{suffix} メソッドのための第2のテスト: 対象がサフィックスを持たない}
testSuffixNotFound
	self assert: 'readme' suffix = ''
\end{method}

\needlines{2}
\dothis{ \mthref{testNoSuffix} を \clsind{StringTest} クラスのテストスイートに追加してテストがエラーを起こすところを見ます。
\sunit でエラーが起きたテストを選択してデバッガに入り、テストをパスするためにコードを編集します。
もっとも簡単で明解な方法は \ct{detect:} メッセージの代わりに \ct{detect:ifNone:} を用いて、二番目の引数を単純に文字列の大きさを返すブロックとする方法です。}

SUnitについては \charef{SUnit} でもっと詳しく学びます。

% section debugger (end)

%=========================================================
\section{[Process Browser]}

\st はマルチスレッドなシステムです。イメージ中では、たくさんの軽量プロセス(スレッドとして知られる)が平行して走っています。
将来的には \pharo の仮想機械は可能ならばマルチプロセッサを利用するようになるかもしれませんが、現時点では、平行性は時分割処理で実装されています。

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{processBrowser}}
		{\includegraphics[width=0.7\textwidth]{processBrowser}}
	\end{center}
	\caption{[Process Browser]}
	\figlabel{processBrowser}
\end{figure}

プロセス \subind{プロセス}{ブラウザ} は \pharo の中で稼働している様々なプロセスを見せてくれるという点でデバッガのいとこに相当します。
\figref{processBrowser} にスクリーンショットをあげておきます。
左上のペインは、優先度80の割り込みタイマー監視プロセスから優先度10のアイドルプロセスに至るまで \pharo の中の全てのプロセスの優先度順のリストです。
もちろん、単一プロセッサ上ですので、見ている時に動いてる唯一のプロセスはUIプロセスです。そのほかの全てのプロセスはなんらかのイベントを待ち続けています。
デフォルトでは、プロセスの表示は静的ですが、\actclick{ing} から \menu{turn on auto-update(a)} を選ぶことで更新することができます。

左上のペインでプロセスを選択すると、丁度、デバッガのように、スタックトレースが右上のペインに表示されます。
スタックトレースを選択すると該当するメソッドが下部のペインに表示されます。
[Process Browser]は \self や \lct{thisContext} のためのmini-インスペクタを備えてはいませんが、スタックトレースで \actclick{ing} することにより同様の機能を提供しています。

%=========================================================
\section{メソッド検索}
\seclabel{methodFinder} 

\pharo にはメソッド検索のための2つのツールがあります。
両者はインタフェースと機能性が異なっています。

\emph{[Method Finder]}は \secref{quick:methodFinder} である程度説明しましたが、メソッドを名前や機能性から探すことができます。しかしメソッドの本体を見ようとすると[Method Finder]は新しくブラウザを開いてしまいます。
これではすぐにウィンドウがいっぱいになってしまいます。

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{methodNamesRandom}}
		{\includegraphics[width=0.7\textwidth]{methodNamesRandom}}
	\end{center}
	\caption{\ct{random} を部分文字列としてセレクタ名に持つ全てのメソッドを表示している[Message Names Browser]}
	\figlabel{methodNamesRandom} % should be *message* names!
\end{figure}

\index{message names browser}
\emph{[Message Names Browser]} はより特別な検索の機能性を有してます。検索用の入力ボックスにメッセージ・セレクタの一部をタイプすると、ちょうど \figref{methodNamesRandom} のように、名前にその一部を含んだすべてのメソッドがブラウザにリストされます。
さらに、これは一人前のブラウザでもあります。
左のペインの名前の一つを選択すると、その名前を持つすべてのメソッドが右側のペインにリストされます。そして、下部のペインで内容を見ることができるのです。
ブラウザが持っているように、[Message Names Browser]はボタン・バーを備えていて、選択したメソッドやそのクラスを他のブラウザで開くことができます。

% section methodFinder (end)

%=========================================================
\section{チェンジセットと[Change Sorter]}
\seclabel{env:changeSet} % (fold)

\pharo で仕事をしている間、メソッドやクラスに対するどんな変更も \lct{チェンジセット} に記録されます。
これには、新しいクラスの作成や、クラス名の変更や、カテゴリの変更や既存のクラスへのメソッドの追加など\,---\,重要なすべてのことが含まれています。
しかし、気ままな \emph{doits} は含まれません。ですので、たとえばワークスペースで新しくグローバル変数を定義したとしても変数の作成手続きは\subind{file}{チェンジセット}に残りません。
\index{change sorter}

どんな時でも、たくさんのチェンジセットが存在している場合でも、その中のたった一つがイメージに対する変更を収集しています。\,---\,それは \lct{カレントチェンジセット} です\,---\, 
\menu{World \go Tools \ldots \go Change Sorter}を選択して出てくる[Change Sorter]を使えば、どのチェンジセットがカレントであるのか、またすべてのチェンジセットについて調べることができます。

\begin{figure}[btp]
	\begin{center}
		\includegraphics[width=\linewidth]{changeSorter}
	\end{center}
	\caption{[Change Sorter]}
	\figlabel{changeSorter}
\end{figure}

\figref{changeSorter} に閲覧画面を示します。タイトルバーはどのチェンジセットがカレントであるのかを表示します。また、それは[Change Sorter]が開いた時に選択されているチェンジセットでもあります。

左上のペインで他のチェンジセットを選ぶことができます。さらに \actclick メニューで他のチェンジセットをカレントにしたり、新しいチェンジセットを作ることができます。
次のペインは選択したチェンジセット(とそのカテゴリ)に影響を受けているすべてのクラスをリスト表示しています。
一つクラスを選択するとそのチェンジセットに存在するメソッド(クラスの全てのメソッド \emph{ではなく})の名前が左の中央のペインに表示され、さらにメソッド名を選択するとメソッドの定義が下のペインに表示されます。
[Change Sorter]は、チェンジセットの一部としてクラスそれ自体の姿を見せている訳 \emph{ではない} ことに注意してください。その情報はチェンジセットを表現するためのオブジェクト構造に格納されているものであります。

[Change Sorter]は該当する項目の \actclick メニューでクラスやメソッドをチェンジセットから削除することもできます。

%  However, for more elaborate editing of change sets, you should use a second tool, the \textit{change sorter}, available by selecting \menu{World\go{}open \ldots \go{}dual change sorter}, which is shown in \figref{changeSorter}.
% The change sorter is essentially two change set browsers side by side; each side can focus on a different change set, class, or method.

[Change Sorter]は同時に二つのチェンジセットを扱えます、一つは左側でもう一つは右側のビューです。
この配置は、 \figref{changeSorter} の \actclick メニューに示されてるように、一つのチェンジセットから別のチェンジセットへメソッドを移動したりコピーしたりする[Change Sorter]の最も重要な機能を支援します。
同様に個々のメソッドごとに一方からもう一方へコピーすることもできます。

みなさんは、どうしてチェンジセットなるものを扱わなければならないのか疑問に思うかもしれません。
その答えは、チェンジセットは \pharo からファイルシステムにコードを書き出すシンプルな仕組みを提供しているからです。これでコードを他の \pharo イメージに取り込むことや、\pharo 以外の \st に取り込むことができるからです。
チェンジセットの書き出しは ``ファイルアウト'' として知られていますが、チェンジセットや、ブラウザのクラスもしくはメソッドで \actclick メニューにより行うことができます。
ファイルアウトを繰り返すとファイルの新しいバージョンが生成されますが、チェンジセットは Monticello のようなバージョン管理ツールではありませんし、依存関係の追跡もしません。
\index{file!filing out}

Monticello の出現以前、チェンジセットは Smalltalker の間でコードを交換する主たる手段でした。
単純さ(ちなみにファイルアウトしたものは単なるテキストファイルですが、テキストエディターで編集するようなことは \emph{お勧めしません} )と可搬性の高さには優位性があります。
%It's also quite easy to create a change set that makes changes to many different, unrelated parts of the system\,---\,something that Monticello is not yet equipped to do.
%\ab{Or is it?}
%\on{you mean something different than extensions to foreign packages using the *package protocol notation?}

\ind{Monticello} パッケージと比較して、チェンジセットの主な欠点としては、依存関係の概念をサポートしてない点があげられます。
あるファイルアウトしたチェンジセットは \emph{アクション} の集合であり、それを読み込んだ先のイメージへ変更を加えます。チェンジセットを無事に読み込むためには、イメージはふさわしい状態にあることが求められます。
たとえば、チェンジセットがあるクラスへメソッドを追加するアクションを含んでいるとする場合、イメージにすでにそのクラスが定義されている時のみに完了することができます。
同様にチェンジセットはクラス名の変更やカテゴリ変更をしている場合、当然そのクラスがイメージに存在している時のみに有効です。その一方で、ファイルアウトした側では定義されているインスタンス変数をメソッドが参照しているのに、それを取り込もうとしているイメージには変数が存在していないということもあり得ます。
問題点はチェンジセットがファイルインできる条件について明示的に表現していないことです。ファイルインのプロセスはうまくいくことが望まれますが、うまくいかない場合、たいてい訳がわからないエラーメッセージとスタックトレースで終わることになります。
複数のファイルインの作業をしていたら、あるチェンジセットが他のチェンジセットによる変更を黙って元に戻してしまうことすらあります。

これとは対照的に Monticello パッケージではコードを宣言的な流儀で表現します。つまり、読み込みが完了後にイメージがどのような状態であるべきかを記述します。
これにより(2つのパッケージが最後の段階で矛盾した要求を持つ場合など)コンフリクトについて警告し、依存関係の順序で一連のパッケージをロードすることを提案してくれます。

しかし、欠点にも関わらず、チェンジセットは未だに使われています。特にみなさんはインターネットで見てみたいと思ったチェンジファイルを探し出して来てことによると使用していたりするでしょう。
それでは、[Change Sorter]を使ってチェンジセットをファイルアウトするところをみてきました。今度はファイルインの方法を説明しましょう。
それには別なツールが必要です。それは[File List Browser]です。
% section changeSet (end)

%=========================================================
\section{[File List Browser]}

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{fileList}}
		{\includegraphics[width=0.7\textwidth]{fileList}}
	\end{center}
	\caption{[File List Browser]}
	\figlabel{fileList}
\end{figure}

要するに \ind{[File List Browser]} は \pharo からファイルシステム(およびFTPサーバーも含めて)をブラウズするための汎用的なツールです。
\menu{World \go{}Tools \dots \go{}File Browser} メニューで開くことができます。見かけはもちろんみなさんのローカルのファイルシステムの内容で変わりますが、典型的なビューを  \figref{fileList} に示します。
\seeindex{file!browsing}{file list browser}

最初に[File List Browser]を開くと、\pharo を起動したディレクトリをカレントディレクトリとして選択された状態になっています。タイトルバーにはこのディレクトリへのパスが表示されています。
左側の大きなペインはよくあるようにファイルシステムを渡り歩くことができます。
ディレクトリが選択されるとそれが持っているファイル(ディレクトリは含まれない[[訳注：実際には表示される？？]])のリストが右側に表示されます。
このファイルのリストはUnix流のパターンをウィンドウの左上にある小さな入力ボックスに入力することでフィルタをかけることができまう。
最初はこのパターンは \ct{*} です。これは全てのファイル名にマッチします。ここで違う文字列をそこに入力してアクセプトするとパターンが変更されます(入力したパターンの前後に暗黙で \ct{*} が付加されることに気をつけてください)。
ファイルの並び順は、\button{name} 、 \button{date} そして \button{size} ボタンで変更できます。
残りのボタンはブラウザで選択したファイル名に依存します。
\figref{fileList} では、ファイル名がサフィックスとして \ct{.cs} を持っています。そこでブラウザはそれはチェンジセットだと推測して、それを \button{install} するためのボタンを提供します(これはファイル名に基づいた名前の新しいチェンジセットに \textit{files it in} します)。ファイルの内容を見るには \button{changes} ボタン、ファイルの内容を実行するには \button{code} ボタン、\button{filein} ボタンで \emph{カレント} のチェンジセットにコードを取り込みます。
\button{conflicts} ボタンはイメージにすでにあるコードとチェンジセットの変更との間のコンフリクトを教えてくれるものと推測するかもしれませんが、これは違います。
その代わりに(ラインフィードの存在のような)ファイルが正しく読み込まれない潜在的な問題をチェックして指摘します。

\begin{figure}[btp]
	\begin{center}
	\ifluluelse
		{\includegraphics[width=\textwidth]{fileContentsBrowser}}
		{\includegraphics[width=0.7\textwidth]{fileContentsBrowser}}
	\end{center}
	\caption{[File Contents Browser]}
	\figlabel{fileContentsBrowser}
\end{figure}

ボタン表示の選択はファイルの内容ではなくファイルの \emph{名前} に依存していることから、時々、希望しないボタンが画面に出て来ます。
しかし、すべてのオプションは常に \actclick の \menu{more \ldots} から利用できますので、簡単にこの問題へ対処できます。

\button{code} ボタンはチェンジセットを使う上でおそらくもっとも便利なものです。これはチェンジセットファイルの内容をブラウザで開きます。例を \figref{fileContentsBrowser} に示します。
この[File Contents Browser]はブラウザによく似ていますが、クラスとプロトコルとメソッドだけを表示してカテゴリの表示がありません。
個々のクラスごとにクラスがすでにシステムに存在しているかどうかファイルで定義されているかどうか(定義が同一か \emph{そうでないか})が分かるようになっています。
個々のクラスのメソッドを表示した上でさらに( \figref{fileContentsBrowser} のように)現在のバージョンとファイルのバージョンとの差分を表示します。
上部の4つのペインのコンテキストメニューはチェンジセット全体をファイルインするのか、それともクラスや、プロトコル、そしてメソッドごとにファイルインするかどうかを指示することができます。

%=========================================================
\section{Smalltalkでは、もうコードを失うことはありません}
\seclabel{cantLoseCode} % (fold)

\pharo がクラッシュすることは十分あり得ることです。というのも、実験的なシステムであり、\pharo が機能するために必要なものを含めて！すべてものが変更可能になっているからです。

\dothis{悪意をもって \pharo をクラッシュさせましょう。 \ct{Object become: nil} を試してみてください}

もしクラッシュしてしまって、何時間も前の最後に保存したバージョンにイメージが戻ってしまったとしても、よい知らせがあります。
それはみなさんがやったことは決して失われないということです。というのも、実行した全てのコードは \emph{.changes} ファイルにすべて保存されているからです。全てです! 
これにはワークスペースで評価した1行プログラムからクラスを追加するプログラミングのコードまで含まれます。
\index{changes}

そこでここからはどのようにコードを回復するかについての手順となります。
これを必要とする時まで、特に読む必要はありません。
しかしながら、それを必要とするときには、ここで見つけるられるようみなさんをお待ちしてます。

最悪の事態では、\emph{.changes} ファイルにテキストエディタを用いることができますが、メガバイトの大きさを持っていることから、冴えないやり方で推奨できません。
\pharo は、よりよい方法を提供しています。

%---------------------------------------------------------
\subsection{コードを回復する方法}
最後のスナップショットの \pharo をリスタートして、 \menu{World\go{}Tools \ldots \go{}Recover lost changes} を選択します。
%This will open a workspace full of useful expressions. The first three,

%\begin{code}{}
%Smalltalk recover: 10000.
%ChangeList browseRecentLog.
%ChangeList browseRecent: 2000.
%\end{code}

%\noindent
%are most useful for recovery.

% If you execute \ct{ChangeList browseRecentLog}, you will be given 

これは、履歴をどれくらい遡って見てみたいか決定する機会を与えてくれます。
通常、最後のスナップショットまでの変更をブラウズするので十分です(同様の効果を \ct{ChangeList browseRecent: 2000} というコードを編集することで得ることができるかもしれませんが、 \ct{2000} という数値は試行錯誤することで他の数値になります)。

\emph{recent changes}ブラウザが表示されますが、これは最後のスナップショットまでの間に \pharo に対して行ったすべての変更のリストです。
このリストから \actclick メニューで項目を削除することができます。
これで十分と判断したら残ったものをファイルインします。このように、新しいイメージに変更を加えます。
実際にファイルインをする前に、普通のチェンジセットブラウザを使って新しいチェンジセットを作るのはいいアイデアです。これによって復元した全てのコードは新しいチェンジセットの中に入るからです。
そしてそのチェンジセットをファイルアウトすることができます。

\emph{recent changes} ブラウザの便利なところは \menu{remove doIts} です。
一般的にdoItsをファイルインしたくない(つまり再実行)したくないことが多いです。
しかしながら例外もあります。
クラス定義は \menu{doIt} として表現されます。
さらに \emph{あるクラスのメソッドをファイルインする前にクラスは存在していなければなりません。}
そこで新しいクラスを定義する際には、\emph{まず最初に}クラス定義をファイルインします。その上で \menu{remove doIts} してメソッドをファイルインします。
%\lr{Maybe mention that class renames are not logged and completely screw up the change-set mechanism. (p. 174)}

リカバリが完了したら、新しいチェンジセットをファイルアウトしてイメージを保存することなく \pharo を終了します。再起動したらきれいな状態で新しいチェンジセットを適用して確実に元に戻します。
% section cantLoseCode (end)

%=========================================================
\section{章のまとめ}

\pharo で開発作業を効果的に行うためには、環境で提供しているツールについて学習する努力を惜しまないことが重要です。

\begin{itemize}
  \item 標準的な \emph{ブラウザ} は、既存のカテゴリ、クラス、メソッド・プロトコル、そしてメソッドを調べたり、新しく定義するための中心となるインタフェースです。
    ブラウザは、メッセージのセンダやインプリメンタへ直接ジャンプしたりメソッドのバージョン表示など、いくつかの便利なボタンを提供します。
  \item いくつかの異なるブラウザ(OmniBrowser や Refactoring Browser といった)や特殊用途のブラウザ(階層ブラウザなど)がクラスやメソッドへの異なるビューを提供します
  \item どんなツールでも、クラスやメソッドの名前をハイライトさせてから \short{b} のショートカットを使うとすぐにブラウザへジャンプできます。
  \item \ct{SystemNavigation default} というメッセージを送ることで \st システムをプログラミング的にブラウズしていくこともできます。
  \item \emph{Monticello} はクラスやメソッドのパッケージを外部へ出力したり、逆に取り込んだり、バージョン管理や共有するためのツールです。
    Monticello のパッケージはカテゴリとサブカテゴリおよび他のカテゴリに属する関連するメソッドプロトコルから構成されます。
  \item \emph{インスペクタ} と \emph{エクスプローラ} の2つのツールは、イメージの中で生きているオブジェクトを調べたり対話するのに便利なツールです。
    \metaclick{ing} によりモーフィックのハロを出してデバッグハンドル \debugHandle を選択するとツールをインスペクトすることさえできます。
  \item \emph{デバッガ} はエラーが起きた際にプログラムの実行スタックを見せてくれるだけでなく、ソースコードを初めとして、アプリケーションのすべてのオブジェクトとの対話を可能にするツールです。多くの場合、デバッガでソースコードを修正して実行を継続することが可能です。デバッガはSUnit(\charef{SUnit})と並んでテストファースト開発を支援する効果的なツールです。
  \item \emph{[Process Browser]} はイメージの中で現在実行中のプロセスを監視したり照会したり対話させてくれます。
  \item \emph{[Method Finder]} と \emph{[Message Names Browser]} はメソッドの場所を突き止めるツールです。前者は名前がはっきりしないが期待される振る舞いが分かってる時に便利です。後者は名前の一部しか分からない時に閲覧するためのより優れたインタフェースを提供します。
  \item \emph{チェンジセット} はイメージのソースコードへのすべての変更を記録するために自動的に作成されるログです。ソースコードのバージョン管理や交換という点では全般的に Monticello に取って代われていますが、特にまれに発生しうる壊滅的な故障からの復旧などでは未だに便利です。
  \item \emph{[File List Browser]} はファイルシステムを閲覧するツールです。これはファイルシステムからソースコードを \menu{filein} させてくれます。
  \item イメージを保存したりソースコードを Monticello でバックする前にクラッシュしてしまった場合、\emph{[Change List Browser]} を使うことで最新の変更から回復することができます。再実行したい変更を選択して最新のコピーのイメージに取り込むことができます。
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%=========================================================
%---------------------------------------------------------

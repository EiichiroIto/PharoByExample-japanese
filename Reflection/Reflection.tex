% $Author$
% $Date$
% $Revision$

% HISTORY: [see also Metaprogramming2.tex]
% 2007-05-22 - Damien Pollet started (translation from French article by ...?)
% 2008-01-15 - Alex added text
% 2008-12-15 - Oscar revised
% 2009-03-24 - Stef started new chapter (acttalk ... see separate file)
% 2009-06-01 - Oscar started to revise again and add new material
% 2009-06-08 - Lukas -- unsent messages
% 2009-06-15 - Oscar completed revision
% 2009-06-16 _ Stef comments
% 2009-06-17 - Alexandre completed revision
% 2009-06-19 - Lukas comments
% 2009-07-07 - Oscar migrated to Pharo; fixed broken tests
% 2009-08-16 - Oscar indexing and cleaning up loose ends

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi

%=================================================================
\chapter{リフレクション}\chalabel{reflection}

%\alex{I addressed lukas comments using editorial macros. Please, if you read this, remove this comment and remove the editorial macros, else their purpose is diminished}

\indexmain{リフレクション}
\st はリフレクション可能なプログラミング言語です。
つまり、プログラムは自分自身の実行や構造を「（ランタイムシステムに）反映する」ことができます。
% \lr{not only on execution, also on the static model}
ランタイムシステムの\emphind{メタオブジェクト}が通常のオブジェクトのように\emph{具現化}されているので、メタオブジェクトに問い合わせを行ったり、インスペクトして内容を見られます。
\st のメタオブジェクトには、クラス、メタクラス、メソッド辞書、コンパイル済みメソッド、実行時スタックなどがあります。
このようなリフレクションは\emphind{イントロスペクション}とも呼ばれ、多くのモダンなプログラミング言語でサポートされています。

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{reflect}
	\caption{具現化とリフレクション。\figlabel{reflect}} % \lr{not referenced, not sure if I understand it}
\end{figure}

\st では逆の操作も可能で、具現化されたメタオブジェクトを変更して、ランタイムシステムに\emph{反映}させることもできます(\figref{reflect}参照)。
このようなリフレクションは\emph{インターセッション}とも呼ばれ、主に動的なプログラミング言語でサポートされていますが、静的な言語での機能は極めて限られます。

他のプログラム（またはプログラム自身）を操作するプログラムを\emphind{メタプログラム}と呼びます。
リフレクション可能なプログラミング言語は、\ind{イントロスペクション}と\ind{インターセッション}の両方をサポートするべきです。
イントロスペクションとは、言語自身を定義するデータ構造（オブジェクト、クラス、メソッド、実行時スタック）を\emph{検査}できる機能です。
インターセッションとは、そのようなデータ構造を\emph{変更}できる機能です。言い換えると、言語の意味論やプログラムの振る舞いを、プログラム自身が変更できる機能です。
ランタイムシステムのデータ構造を検査・変更することを\emph{構造的リフレクション}と呼び、データ構造の解釈の仕方を変更することを\emphind{振る舞い的リフレクション}と呼びます。

この章では、主にind{構造的リフレクション}を扱います。
例と多数挙げながら、 \st がどのようにイントロスペクションとメタプログラミングをサポートしているのかを探っていきます。

%======================================
\section{イントロスペクション}

インスペクタを使うと、オブジェクトの内容を見たり、インスタンス変数の値を変更したり、オブジェクトにメッセージを送ることもできます。

\dothis{次のコードをワークスペースで評価してみましょう:}
\begin{code}{| w |}
w := Workspace new.
w openLabel: 'My Workspace'.
w inspect
\end{code}

このコードを評価すると、インスペクタとワークスペースがもう一つ開きます。
このインスペクタは新しく開いたワークスペースの内部状態を示しており、左ペインにはインスタンス変数（\ct!dependents!, \ct!contents!, \ct!bindings! など）、右ペインには選択したインスタンス変数の値が表示されます。
\ct!contents!インスタンス変数は、ワークスペースのテキストエリアに表示されている内容を表します。\ct!contents!を選択すると、インスペクタの右ペインには空文字列が表示されます。

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{workspaceInspector}
	\caption{\lct!ワークスペース!をインスペクトしている様子。\figlabel{workspaceInspector}}
\end{figure}

\dothis{この空文字列のところに\ct!'hello'!と入力して、\emph{accept}してみましょう。}
これで\ct!contents!変数の値が変りますが、まだワークスペースウィンドウは変化に気付かないので再描画されません。
ウィンドウを更新させるには、インスペクタの下ペインで\ct!self contentsChanged!を評価します。

%-----------------------------------------------------------------
\subsection{インスタンス変数へのアクセス}

インスペクタはどのように動いているのでしょうか？
\st では、インスタンス変数はすべて保護されています。
この理屈から言えば、クラスが何らかのアクセサメソッドを定義していない限り、他のオブジェクトからインスタンス変数にアクセスさせることはできません。
しかし実際には、インスペクタはアクセサメソッドがなくてもインスタンス変数にアクセスできます。これは\stがリフレクション可能だからです。
\st では、クラスはインスタンス変数を名前または数値の添字で定義します。
インスペクタは、\ct!Object!クラスで定義されているメソッド \lct{instVarAt: \emph{index}} または \lct{instVarNamed: \emph{aString}} を使ってインスタンス変数にアクセスします。数値の添字 \lct{\emph{index}} で位置を指定するか、インスタンス変数名 \lct{\emph{aString}} を指定します。インスタンス変数に新しい値を代入するには、\ct!instVarAt:put:! か \ct!instVarNamed:put:! を使います。
\mthindex{Object}{instVarAt:}
\mthindex{Object}{instVarNamed:}
\mthindex{Object}{instVarAt:put:}
\mthindex{Object}{instVarNamed:put:}

例えば次のコードを評価すると、最初のワークスペースで変数 \ct!w! に束縛されていたオブジェクトの内部状態を変更できます。

\begin{code}{}
w instVarNamed: 'contents' put: 'howdy!'; contentsChanged
\end{code}

\important{\emph{注意:} これらのメソッドは開発ツールを作る分には便利ですが、通常のアプリケーションの開発にはよくありません。リフレクション可能なメソッドはオブジェクトのカプセル化の境界を壊すので、理解も保守も難しいコードを生んでしまいます。}
% \lr{Why? The access does not show up when looking for all readers/writers in the code browser.}

\ct!instVarAt:!と\ct!instVarAt:put:!は\ind{プリミティブメソッド}です。プリミティブメソッドは、バーチャルマシンのプリミティブな操作として実装されています。
これらのメソッドのコードを調べれば、特殊な\ind{プラグマ}構文 \ct!<primitive: N>! （\ct!N!は整数）が見つかるでしょう。
% \lr{actually this is the syntax of pragmas (method annotations), \ct!primitive:! is just a special kind of pragma}

\needlines{5}
\begin{code}{}
Object>>>instVarAt: index 
	"プリミティブ。オブジェクト内の固定長配列で管理されているインスタンス変数を返す。"
	!\textbf{<primitive: 73>}!
	"固定長配列の範囲を超えてアクセスする。"
	^self basicAt: index - self class instSize		
\end{code}

プリミティブに続くコードは、プリミティブが失敗した場合にのみ実行されます。
\ct!instVarAt:!では、存在しないインスタンス変数にアクセスしようとすると、プリミティブに続くコードが実行されます。
こうすれば、プリミティブメソッドが失敗したときにデバッガを起動できます。
プリミティブメソッドのコードは変更できますが、\pharo システムの安定性を脅かしかねないため注意してください。

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{allInstanceVariables}
	\caption{\ct!Workspace!のすべてのインスタンス変数を表示している様子。\figlabel{allInstanceVariables}}
\end{figure}

\figref{allInstanceVariables}は、\ct!Workspace!クラスのインスタンス（\ct!w!）の任意のインスタンス変数を表示する方法を示しています。
\ct!allInstVarNames!メソッドは、与えられたクラスのすべてのインスタンス変数の名前を返します。

同様の方法で、同じ特徴を持つインスタンスを集めることもできます。
例えば\ct!SketchMorph!クラスのインスタンスのうち、\ct!owner!インスタンス変数の内容がワールドモーフであるもの（\ie 現在表示されているすべてのイメージ）を集めてみましょう。次の式を試してみてください。

\begin{code}{}
SketchMorph allInstances select: [:c | (c instVarNamed: 'owner') isWorldMorph]
\end{code}

%-----------------------------------------------------------------
\subsection{インスタンス変数について繰り返し処理する}

\mthindex{Object}{instanceVariableValues}
\ct!instanceVariableValues!メッセージについて調べてみましょう。このメソッドは、すべてのインスタンス変数（継承したものは除く）の値のコレクションを返します。
次に例を示します:
\begin{code}{@TEST}
(1@2) instanceVariableValues --> an OrderedCollection(1 2)
\end{code}

このメソッドは\ct{Object}クラスで次のように実装されています:
\needlines{9}
\begin{code}{}
Object>>>instanceVariableValues
	"レシーバのクラスが定義したインスタンス変数の値を集めたコレクションを返す。"	
	| c |
	c := OrderedCollection new.
	self class superclass instSize + 1
		to: self class instSize
		do: [ :i | c add: (self instVarAt: i)].
	^ c
\end{code}

このメソッドは、レシーバのクラスが定義しているインスタンス変数の添字に基づいて、インスタンス変数の値を集めます。この添字は、スーパークラスで使われている最後の添字の直後の値から始まります。
（\ct!instSize! メソッドは、クラスが定義している名前付きのインスタンス変数の数を返します）。

%-----------------------------------------------------------------
\subsection{クラスやインターフェースへの問い合わせ}

\pharo の開発ツール（コードブラウザ、デバッガ, インスペクタなど）はすべて、これまでに見て来たリフレクション可能な機能を使っています。

もういくつか、開発ツールにとって役立つメッセージを挙げましょう:

\lct{isKindOf: \emph{aClass}}は、レシーバが\lct{\emph{aClass}}や、そのスーパークラスのいずれかのインスタンスであれば真を返します。例:

\begin{code}{@TEST}
1.5 class                     --> Float
1.5 isKindOf: Number --> true
1.5 isKindOf: Integer   --> false
\end{code}
\mthindex{Object}{class}
\mthindex{Object}{isKindOf:}

\lct{respondsTo: \emph{aSymbol}}は、セレクタが\lct{\emph{aSymbol}}であるメソッドをレシーバが持っていれば真を返します。例:

\needlines{3}
\begin{code}{@TEST}
1.5 respondsTo: #floor      --> true    "Numberクラスはfloorを実装しています"
1.5 floor                            --> 1
Exception respondsTo: #, --> true    "例外クラスはグループ化できます"
\end{code}
\mthindex{Object}{respondsTo:}

\important{\emph{警告:}ここで紹介した機能は、開発ツールにとっては便利ですが、普通のアプリケーションには適していません。
オブジェクトが属するクラスや理解できるメッセージを調べようとするのは、設計に問題がある兆候です。カプセル化の原則に反しています。
ただし、開発ツールは普通のアプリケーションではありません。開発ツールはソフトウェアそのものを扱うので、コードの内部を詳細に調べる権利があります。}

%There also exist mechanisms for introspecting on various parts of the run-time system, such as  the process scheduler, the memory manager and so on. For now we will focus on navigating through objects, classes and methods, and we will look more closely at rest of the runtime system in an other chapter.
%\on{let's not mention this if we don't actually write such a chapter!}

%-----------------------------------------------------------------
\subsection{コードメトリクス}

\st のイントロスペクションを使えば、コードメトリクスを簡単に調べられます。使い方を見てみましょう。
コード\ind{メトリクス}では、次のようなコードの特徴を調べます。継承の階層の深さ、直接的・間接的なサブクラスの数、各クラスのメソッドやインスタンス変数の数、クラスで新しく定義されたメソッドやインスタンス変数の数などです。
次に\ct!Morph!クラスのメトリクスをいくらか示します。\ct!Morph!クラスは\pharoのすべてのグラフィカルなオブジェクトのスーパークラスであり、巨大なクラスであり、巨大な継承階層のルートクラスだとわかります。リファクタリングが必要かもしれません！

\mthindex{Behavior}{allSuperclasses}
\mthindex{Behavior}{allSelectors}
\mthindex{Behavior}{allInstVarNames}
\mthindex{Behavior}{selectors}
\mthindex{Behavior}{instVarNames}
\mthindex{Behavior}{subclasses}
\mthindex{Behavior}{allSubclasses}
\mthindex{ClassDescription}{linesOfCode}
\begin{code}{}
Morph allSuperclasses size.  -->       2 "継承階層の深さ"
Morph allSelectors size.        --> 1378 "メソッドの数"
Morph allInstVarNames size. -->      6 "インスタンス変数の数"
Morph selectors size.             -->  998 "Morphで新しく定義されたメソッドの数"
Morph instVarNames size.     -->      6 "Morphで新しく定義されたインスタンス変数の数"
Morph subclasses size.          -->    45 "直接のサブクラスの数"
Morph allSubclasses size.      -->  326 "サブクラスの総数"
Morph linesOfCode.               --> 5968 "総コード行数"
\end{code}

オブジェクト指向言語において最も興味深いメトリクスの一つは、スーパークラスから継承し、拡張したメソッドの数です。
このメトリクスにより、クラスとそのスーパークラスの関係がわかります。
次の節以降では、このような疑問をどう調べていくのかを見ていきます。

%======================================
\section{コードをブラウズする}

\st では、すべてがオブジェクトです。特にクラスオブジェクトは、クラスのインスタンスの世界をナビゲートするための、便利な機能を提供します。
これから見るメッセージの多くは、\ct{Behavior}で実装されているので、すべてのクラスが(\ct{Class}は、\ct{Behavior}を継承しています)、これらのメッセージを理解できます。

\figref{allInstanceVariables}で見たように、与えられたクラスのインスタンスは、そのクラスに\ct!#someInstance!メッセージを送れば、得られます。
\mthindex{Behavior}{someInstance}
\begin{code}{@TEST} % Possibly fragile!
Point someInstance --> 0@0
\end{code}

また、すべてのインスタンスを集めるのに、\ct!#allInstances!を用いることができます。さらに、メモリ中にあるインスタンスの数は、\ct!#instanceCount!を使えばわかります。

\alex{In a Pharo0.1-10342dev09.96.3, I have "ByteString instanceCount --> 63607"}
\mthindex{Behavior}{allInstances}
\mthindex{Behavior}{instanceCount}
\mthindex{Behavior}{allSubInstances}
\begin{code}{} % Cannot test this
ByteString allInstances        --> #('collection' 'position'  ...)
ByteString instanceCount    --> 104565
String allSubInstances size -->  101675
\end{code}

以下の機能は、アプリケーションをデバッグするときに、非常に便利なことがあります。なぜなら、クラスに対して、特定の属性を示すメソッドを列挙するよう依頼できるからです。
\begin{itemize}
\item \mthind{Behavior}{whichSelectorsAccess:} 引数が指定したインスタンス変数を読み書きするメソッドの、すべてのセレクターを返す
\item \mthind{Behavior}{whichSelectorsStoreInto:} インスタンス変数の値を変更するメソッドのセレクターを返す
\item \mthind{Behavior}{whichSelectorsReferTo:} 与えられたメッセージを送るメソッドのセレクターを返す
\item \mthind{Behavior}{crossReference} 各メッセージを、そのメッセージを送るメソッドの集合に関連づける
\end{itemize}

\begin{code}{} % TOO FRAGILE TO TEST
Point whichSelectorsAccess: 'x'    --> #(#'\\' #= #scaleBy: ...)
Point whichSelectorsStoreInto: 'x' --> #(#setX:setY: ...)
Point whichSelectorsReferTo: #+  --> an IdentitySet(#rotateBy:about: ...)
Point crossReference --> an Array(
		an Array('*' an IdentitySet(#rotateBy:about: ...))
		an Array('+' an IdentitySet(#rotateBy:about: ...))
		...)
\end{code}

以下のメッセージは、継承を考慮に入れます:
\begin{itemize}
\item \mthind{Behavior}{whichClassIncludesSelector:} 与えられたメッセージを実装するクラス/スーパークラスを返す
\item \mthind{Behavior}{unreferencedInstanceVariables} レシーバークラスでも、そのどのサブクラスでも使われない、インスタンス変数のリストを返す
\end{itemize}

\begin{code}{@TEST}
Rectangle whichClassIncludesSelector: #inspect --> Object
Rectangle unreferencedInstanceVariables            --> #()
\end{code}

\clsind{SystemNavigation}は、さまざまな便利なメソッドをサポートするファサードです。ここで言うメソッドとは、システムのソースコードにクエリを送ったり、これをブラウズするのに便利なメソッドのことです。
\ct{SystemNavigation} \mthind{SystemNavigation class}{default}は、システムをナビゲートするのに使えるファサードのインスタンスを返します。
例えば:

\mthindex{SystemNavigation}{allClassesImplementing:}
\begin{code}{@TEST}
SystemNavigation default allClassesImplementing: #yourself --> {Object}
\end{code}

以下のメッセージの意味も、その名の通りでしょう:

\mthindex{SystemNavigation}{allSentMessages}
\mthindex{SystemNavigation}{allUnsentMessages}
\mthindex{SystemNavigation}{allUnimplementedCalls}
\begin{code}{}
SystemNavigation default allSentMessages size          --> 24930
SystemNavigation default allUnsentMessages size      --> 6431
SystemNavigation default allUnimplementedCalls size --> 270
\end{code}

ここで次のことに注意してください。実装されてはいても送られないメッセージは、必ずしも不要ということではありません。なぜなら、それらは暗黙のうちに送られることもあるからです(\eg \ct{perform:}を使って)。
送られるのに実装されていないメッセージは、しかし、もっとやっかいです。なぜなら、これらのメッセージを送るメソッドは、いずれ実行時に失敗するからです。
これらは、完了していない実装、廃止されたAPI、あるいは欠落したライブラリがあることを、示しているのかもしれません。

\mthindex{SystemNavigation}{allCallsOn:}
\ct!SystemNavigation default allCallsOn: #Point! は、\ct!Point!レシーバーに明示的に送られるすべてのメッセージを返します。

これらすべての機能は、\pharo のプログラミング環境、特にコードブラウザー、に統合されています。
きっとすでにお気付きでしょうが、次のような便利なキーボードショートカットがあります: すべてのインプリメンター(i\underline{m}plementors)をブラウズするための(\short{m})、そして、与えられたメッセージのセンダー(se\underline{n}ders)をブラウズするための(\short{n})。
おそらく、それほどよく知られていないのは、このようなパッケージ済みのたくさんのクエリが、\ct{SystemNavigation}クラスの\prot{browsing}プロトコルのメソッドとして実装されていることです。
例えば、以下を評価すれば、プログラム的に、\ct{ifTrue:}メッセージを実装しているすべてのクラスをブラウズできます:
\mthindex{SystemNavigation}{browseAllImplementorsOf:}
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #ifTrue:
\end{code}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{implementors}
	\caption{すべての\ct!\#ifTrue:!の実装をブラウズしている様子。\figlabel{implementors}}
\end{figure}

特に便利なのは、\ct{browseAllSelect:}と、\lct{browseMethodsWithSourceString:}の2個のメソッドです。以下では、システム中のすべてのメソッドのうち、\super-送信を行うものをブラウズする、ふたつの異った方法を示します(最初の方法は、いくぶん総当たり式の方法です; 2番目の方法は、より優れており、検索結果の中から不必要なものをいくぶん減らすことができます):
\mthindex{SystemNavigation}{browseMethodsWithSourceString:}
\mthindex{SystemNavigation}{browseAllSelect:}
\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'super'.
SystemNavigation default browseAllSelect: [:method | method sendsToSuper ].
\end{code}

%======================================
\section{クラス、メソッド辞書、そしてメソッド}

クラスはオブジェクトなので、他のあらゆるオブジェクトとまったく同様、クラスをインスペクトやエクスプロアできます。

\mthindex{Object}{explore}
\dothis{\ct{Point explore}を評価してみましょう。}

\figref{CompiledMethod}では、\ind{エクスプローラー}が、\clsind{Point}クラスの構造を示しています。
ここでは、クラスがそのメソッドを辞書に格納しているのが確認できます。そしてメソッドのセレクターが、辞書の見出しになっています。
セレクター\ct{#*}は、逆コンパイルされた\ct!Point>>>*!の\ind{バイトコード}を指しています。

\begin{figure}[ht]\centering
	\includegraphics[width=.5\linewidth]{CompiledMethod}
	\caption{\ct!Point!クラスと、その\ct!\#*!メソッドのバイトコードをエクスプロアする。\figlabel{CompiledMethod}}
\end{figure}

クラスとメソッドの関係について考えてみましょう。
\figref{MethodsAsObjects}を見ると、クラスとメタクラスには共通のスーパークラス、\ct{Behavior}、があることがわかります。\ct{Behavior}クラスで、\mthind{Behavior}{new}が定義されています。\ct{new}はクラスの他の主要なメソッドのひとつにすぎません。
どのクラスにもメソッド辞書があって、メソッド辞書は、メソッドセレクターと\ind{コンパイル済みメソッド}を、対応づけます。
コンパイル済みメソッドはそれぞれ、そのメソッドがインストールされているクラスを知っています。
\figref{CompiledMethod}を見れば、\ct{Point}クラスが、\ct!#*!に当たるコンパイル済みメソッドの、\ct{literal5}に、アソシエーションとして格納されていることさえわかります。

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{MethodsAsObjects}
	\caption{クラス、メソッド辞書、そしてコンパイル済みメソッド\figlabel{MethodsAsObjects}}
\end{figure}

クラスとメソッドの関係を活用して、システムについてのクエリを送れます。
例えば、どのメソッドが、与えられたクラスに新規に導入されたかということ、\ie どのメソッドが、スーパークラスのメソッドをオーバーライドしていないか、ということは、以下のように、クラスから\ind{メソッド辞書}をナビゲートすれば見出せます:
\mthindex{Behavior}{methodDict}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger
  --> an IdentitySet(#threeDigitName #printStringBase:nDigits: ...)
\end{code}

コンパイル済みメソッドは、単に、メソッドのバイトコードを格納しているだけではありません。
コンパイル済みメソッド自身が、システムにクエリを送るための多くの便利なメソッドを提供するオブジェクトなのです。
そのようなメソッドのひとつに、\ct{isAbstract}があります(\ct{isAbstract}メソッドは、コンパイル済みメソッドが、\ct{subclassResponsibility}を送るかどうか、教えてくれます)。
\ct{isAbstract}メソッドを使えば、任意の抽象クラスのすべての抽象メソッドを識別できます。
\needlines{4}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass>>aMethod) isAbstract ]] value: Number
  --> #(#storeOn:base: #printOn:base: #+ #- #* #/ ...)
\end{code}
このコードでは、クラスに対して、\ct{>>}メッセージが送られ、その結果、与えられたセレクターに対するコンパイル済みメソッドが得られる、ということに注意してください。

% As a slightly more complex example, we can browse 

与えられた階層内の、例えば、Collectionの階層内の\super-送信をブラウズするには、より洗練されたクエリを送れます:
\begin{code}{}
class := Collection.
SystemNavigation default
  browseMessageList: (class withAllSubclasses gather: [:each |
    each methodDict associations
      select: [:assoc | assoc value sendsToSuper]
      thenCollect: [:assoc | MethodReference class: each selector: assoc key]])
  name: 'Supersends of ' , class name , ' and its subclasses'
\end{code}
関心のあるメソッド(\super-送信をするメソッド)を識別するために、クラスからメソッド辞書へと、そしてメソッド辞書からコンパイル済みメソッドへと、ナビゲートしている様子に注意してください。
\ct{MethodReference}は、コンパイル済みメソッドのための軽量プロキシーで、たくさんのツールがこのプロキシーを使っています。
\clsmthind{CompiledMethod}{methodReference}という簡易メソッドがあって、これは、コンパイル済みメソッドに対するメソッド参照(\ct{MethodReference})を返します。
\begin{code}{@TEST}
(Object>>#=) methodReference methodSymbol --> #=
\end{code}

%======================================
\section{ブラウザー環境}

\clsind{SystemNavigation}は、システムコードに対して、プログラム的にこれにクエリを送り、これをブラウズする便利な方法をいくつか提供しますが、もっとよい方法があります。\pharo には\ind{リファクタリングブラウザー}というものが統合されているのですが、これを使えば、複雑なクエリを、会話的にもプログラム的にも送れます。

\lct{Collection}の階層の中の、どのメソッドが、そのメソッドのセレクターと異なるメッセージを\super に送っているかに関心があったとしましょう。
このように、何かをオーバーライドしているわけではないメソッドが、\super-送信をしているのは、通常は、悪い\ind{コードの臭い}と考えられます。なぜなら、そのような\super-送信は、通常は、\self-送信で置き換えられるべきだからです。(次のことを考えてみてください --- \super は、メソッドをオーバーライドするときにだけ\emph{必要}です; 他のすべての継承されたメソッドにアクセスするには、\self にメッセージを送れば済みます!)

リファクタリングブラウザーは、クエリの送り先を、関心のあるクラスやメソッドに限定するための、エレガントな方法を提供します。

\dothis{ブラウザーを開けて、\ct{Collection}を見てみましょう。
クラス名を\actclick して、\menu{refactoring scope>subclasses with}を選択しましょう。
こうすると、\ct{Collection}階層に限定されたブラウザー環境が、新規に開きます。
この限定されたスコープの中で、\menu{refactoring scope>super-sends}を選択しましょう。すると、新しいウィンドウ環境が開き、\ct{Collection}階層の中で、\super-送信を行っているすべてのメソッドが列挙されます。
ここで、任意のメソッドを\click し、\menu{refactor>code critics}を選んでみましょう。
\menu{Lint checks>Possible bugs>Sends different super message}とナビゲートして、\menu{browse}を\actclick してみましょう。}

\figref{sendDifferentSuper}を見れば、そのようなメソッドが19個、\ct{Collection}階層の中に見つかったことがわかります。それらの中には、\ct{Collection>>>printNameOn:} があって、このメソッドは、\ct{super printOn:}を送っています。
\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{sendDifferentSuper}
	\caption{自身のセレクターとは異なるsuperメッセージを送信しているメソッドを、見つけている様子。\figlabel{sendDifferentSuper}}
\end{figure}

ブラウザー環境はまた、プログラム的に作れます。
例えば、以下のように、\clsind{Collection}とそのサブクラスについての新しい\clsind{BrowserEnvironment}のインスタンスを生成して、\super-送信をしているメソッドを抽出し、結果を\ct{SelectorEnvironment}オブジェクトとして表示できます。
\needlines{4}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
	selectMethods: [:method | method sendsToSuper])
	label: 'Collection methods sending super';
	open.
\end{code}{}

この例は、先程の、\ct{SystemNavigation}を用いたこれと等価な例より、かなりコンパクトになっていることに注意してください。

最終的に、以下のようにして、自身のメソッドセレクターと異なったsuperメッセージを送っているメソッドだけを、プログラム的に見つけ出せます:
\needlines{6}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
	selectMethods: [:method | 
		method sendsToSuper
		and: [(method parseTree superMessages includes: method selector) not]])
	label: 'Collection methods sending different super';
	open
\end{code}
ここでは、各コンパイル済みメソッドに、(リファクタリングブラウザによる)解析木について尋ね、superメッセージが、メソッドのセレクターと異なっているかを探り出しています。
\ct{RBProgramNode}クラスの\prot{querying}プロトコルを見てみましょう。これを見れば、解析木に対して、何が尋ねられるかがわかります。

%======================================
\section{実行時コンテクストにアクセスする}

これまで、\st のリフレクティブな機能をどのように用いれば、オブジェクト、クラス、メソッドにクエリを送ったり、これらをエクスプロアしたりできるのかを見てきました。しかし、実行時環境についてはどうでしょう?

%-----------------------------------------------------------------
\subsection{メソッドコンテクスト}

実際、メソッドの実行時コンテクストは、仮想マシンの中にあります --- 決して、仮想イメージの中にはありません!
その一方で、\ind{デバッガー}はもちろん、この実行時コンテクストにアクセスできます。そして幸いにも、この実行時コンテクストをエクスプロアできます。それはちょうど、他の任意のオブジェクトをエクスプロアできるのと同様です。
これは、どのようにして可能になっているのでしょうか?

実は、デバッガーには何の魔法もありません。
秘密は、\pvind{thisContext}という疑似変数にあります。これには、以前、少しだけ触れました。
実行中のメソッドが\ct{thisContext}を参照したとき、そのメソッドの完全な実行時コンテクストが具現化され、\clsind{MethodContext}オブジェクトの一連の連鎖として、仮想イメージから利用できるようになります。

このメカニズムについて、簡単に、自分で実験できます。

\dothis{\ct{Integer>>>factorial}の定義を、下線部の式を挿入して、以下のように変えてみましょう:}

\mthindex{Object}{halt}
\begin{code}{}
Integer>>>factorial
	"レシーバーの階乗を返す。"
	self = 0 ifTrue: [!\underline{thisContext explore. self halt.}! ^ 1].
	self > 0 ifTrue: [^ self * (self - 1) factorial].
	self error: 'Not valid for negative integers'
\end{code}

\dothis{ここで、\ct{3 factorial}を、ワークスペースで評価してみましょう。\figref{exploringThisContext}が示すように、デバッガーウィンドウとエクスプローラーの両方が表示されるはずです。}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{exploringThisContext}
	\caption{\lct{thisContext}をエクスプロアしている様子。\figlabel{exploringThisContext}}
\end{figure}

貧者のデバッガーへようこそ!
ここで今、エクスプロアされたオブジェクトのクラスをブラウズすると(\ie エクスプローラーの下のペインで\ct{self browse}を評価すると)、\ct{thisContext}が、\lct{MethodContext}のインスタンスであることがわかるでしょう。これは、\ct{sender}の連鎖においても同様です。
% All of these objects have been created dynamically in the image by the \st virtual machine at the point where \ct{thisContext} was referred to in the \ct{factorial} method. \lr{Not actually. In all the currently available VMs the context objects are created with every method activation, no matter if they are accessed using \ct{thisContext} or not.}

\ct{thisContext}は、日々のプログラミング用として意図されたものではありませんが、デバッガーのようなツールを実装するにも、コールスタックについての情報にアクセスするにも不可欠です。
以下の式を評価すれば、どのメソッドが\ct{thisContext}を活用しているかを見出せます:

\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'thisContext'
\end{code}

結局のところ、\ct{thisContext}の最も一般的な応用例のひとつは、メッセージのセンダーを見出すことです。
以下は典型的なアプリケーションです:
\begin{code}{}
Object>>>subclassResponsibility
	"このメッセージは問題のクラスの一連のサブクラスの振る舞いについてのフレームワークを提唱する。
	このメッセージがサブクラスで実装済みであるはずだ、と知らせる。"

	self error: 'My subclass should have overridden ', thisContext sender selector printString
\end{code}

慣習により、\st のメソッドで\ct{self subclassResponsibility}を送るものは、抽象メソッドであると考えられます。しかし、\clsmthind{Object}{subclassResponsibility}メソッドは、どのようにして有用なエラーメッセージを提供するのでしょうか? つまり、どのようにして、どの抽象メソッドが呼ばれたか、その名前を示すのでしょうか? 非常に単純です。\ct{thisContext}にセンダーを尋ねるのです。

\lr{I think co-routines and continuations should at least mentioned here. Another very practical application that is simple and could be shown here is the ``escaper''. Store the current context into a temp or inst-var \ct{target := thisContext} and jump back to that stack frame at a later point in time using \ct{target return: 123}.}
\sd{lukas maybe we should have another chapter showing such kind of beasts. I would love to read it.
Showing how to use block to build exception and such a kind of point. I think that this chapter should be an introduction may be
we should have a Reflection applied chapter}
\lr{I would love to help writing such a chapter}
%-----------------------------------------------------------------
\subsection{賢いブレークポイント}

\mthindex{Object}{halt}
ブレークポイントをかけるための\st のやりかたは、メソッド内の要所で、\ct{self halt}を評価することです。こうすると、\ct{thisContext}が具現化され、\ind{デバッガー}ウィンドウが、ブレークポイントの所で開きます。
残念なことに、これを、システムで集中的に使われるメソッドに対して行うと、数々の問題を引き起こしす。

例えば、\ct{OrderedCollection>>>add:}の実行を解析したかったとしましょう。
このメソッド内にブレークポイントをかけると、やっかいなことになります。

\dothis{\emph{フレッシュな}仮想イメージを使って、以下のブレークポイントをセットしてみましょう:}
\needlines{3}
\begin{code}{}
OrderedCollection>>>add: newObject
	!\underline{self halt.}!
	^self addLast: newObject
\end{code}

この仮想イメージが、ただちにフリーズする様子に注目してください! デバッガーウィンドウを開けることさえできません。
いったん次のことを理解すれば、問題は明確になるでしょう。(i) \ct{OrderedCollection>>>add:}はシステムの多くの場所で使われているので、ブレークポイントは、変更をacceptしたらすぐにヒットします。実際、(ii) \emph{デバッガーそれ自身}が、\ct{add:}メッセージを\ct{OrderedCollection}のインスタンスに送るので、デバッガーを開けられなくなるのです!
必要なのは、関心があるコンテクスト内でのみ、\emph{条件つきでhalt}する手段です。
\clsmthind{Object}{haltIf:}が提供するのがまさに、この手段です。

ここで、\ct{add:}を、何らかのコンテクスト、例えば、\ct{OrderedCollectionTest>>>testAdd}のコンテクストから呼ばれたときにだけ、haltさせたいとしましょう。

\dothis{再びフレッシュな仮想イメージを立ち上げ、以下のブレークポイントを設定してみましょう:}
\begin{code}{}
OrderedCollection>>>add: newObject
	!\underline{self haltIf: \#testAdd.}!
	^self addLast: newObject
\end{code}

今回は、仮想イメージはフリーズしません。\ct{OrderedCollectionTest}を走らせてみましょう。
(\ct{OrderedCollectionTest}が、\scat{CollectionsTests-Sequenceable}カテゴリに見つかるでしょう。)

これは、どのようにして動くのでしょうか? \clsmthind{Object}{haltIf:}を見てみましょう:
\begin{code}{}
Object>>>haltIf: condition
	| cntxt |
	condition isSymbol ifTrue: [
		"セレクターのシンボルを持つメソッドが、センダーの連鎖内にあったときだけhaltする"
		cntxt := thisContext.
		[cntxt sender isNil] whileFalse: [
			cntxt := cntxt sender. 
			(cntxt selector = condition) ifTrue: [Halt signal]. ].
		^self.
	].
	...
\end{code}

\ct!thisContext!から始めて、\ct!haltIf:!は実行時スタックを上へ上へと遡りながら、呼び出し側のメソッドの名前が、パラメーターと一致するかをチェックします。
もし一致したら、例外を発生させます。そして例外が発生したときのデフォルトの動作として、デバッガーが呼び出されます。

booleanやbooleanブロックを引数として、\ct{haltIf:}を呼ぶこともできますが、これらの場合についての処理は単純で、\lct{thisContext}は活用されません。

%======================================
\section{理解されなかったメッセージをインターセプトする}
\seclabel{msgnotunderstood}

これまでのところ、\st のリフレクティブな機能は、主に、オブジェクト、クラス、メソッド、そして実行時スタックにクエリを送ったり、これらをエクスプロアするのに用いてきました。ここからは、\st のシステムの構造に関する知識をどのように使えば、メッセージをインターセプトして、その振る舞いを実行時に変えられるか、見ていきます。

オブジェクトがメッセージを受け取ったとき、オブジェクトはまず、そのクラスのメソッド辞書を引いて、メッセージに対応するメソッド、つまり、このメッセージに応答するメソッドを探します。
もし、そのようなメソッドが存在しなければ、クラス階層を上へ上へとたどっていきます。これは場合によっては\ct{Object}にたどりつくまで続けられます。もし、そこでもメッセージに対するメソッドが見つからなかったら、オブジェクトは、\ct{doesNotUnderstand:}を、\emph{自分自身に送ります}。\ct{doesNotUnderstand:}の引数は、理解されなかったメッセージ(\clsind{Message}のインスタンス)です。
このメソッド検索のプロセスは、振り出しに戻って再開され、\clsmthind{Object}{doesNotUnderstand:}が見つかるまで続けられ、そしてデバッガーが立ち上がります。

しかし、もし\ct{doesNotUnderstand:}が\ct{Object}のサブクラスでオーバーライドされていて、メソッドの検索パスに入っていたらどうなるでしょう?
結局のところ、これは、ある種の非常に動的な振る舞いを実現するのに便利な方法です。あるメッセージが理解できないオブジェクトは、\ct{doesNotUnderstand:}をオーバーライドすることで、理解できなかったメッセージに応答するための、代替えの戦略に頼れるのです。

このテクニックの非常に一般的な応用をふたつ挙げると、(1) オブジェクトの\ind{軽量プロキシー}の実装、そして、(2) 欠けているコードの、動的なコンパイルまたはロード、です。

%-----------------------------------------------------------------
\subsection{軽量プロキシー}

最初の例として、「\ind{最小限のオブジェクト}」を紹介します。これは、既存のオブジェクトのプロキシーとして振る舞います。
このプロキシーは実質的には、それ自身のメソッドを何ら持たないので、プロキシーに送られたどのメッセージも、\ct{doesNotUnderstand:}で捕捉されます。この\ct{doesNotUnderstand:}メッセージを実装すれば、プロキシーは、それが代理を務める実体にメッセージを移譲する前に、特別なアクションを取れます。

このプロキシーを、どのように実装できるか、見てみましょう。\footnote{\pkg{PBE-Reflection}を\url{http://www.squeaksource.com/PharoByExample/}からロードできます}。

\ct{LoggingProxy}を以下のように定義します:
\begin{code}{}
ProtoObject subclass: #LoggingProxy
	instanceVariableNames: 'subject invocationCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Reflection'
\end{code}
\ct{Object}ではなく\ct{ProtoObject}のサブクラスとして定義していることに注意してください。なぜなら、\ct{Object}からこのプロキシーに、400個以上のメソッド(!)を継承したくないからです。

\begin{code}{}
Object methodDict size --> 408
\end{code}

このプロキシーにはふたつのインスタンス変数があります: \ct{subject} これは、このプロキシーが代理を務める実体です。そして\ct{invocationCount}は、このプロキシーがインターセプトしたメッセージの数です。
これらふたつのインスタンス変数を初期化し、インターセプトしたメッセージの数(\ct!invocationCount!)を返すアクセサーを提供します。
最初は\ct{subject}変数は、プロキシーオブジェクトそれ自身を指しています。
\begin{code}{}
LoggingProxy>>>initialize
	invocationCount := 0.
	subject := self.
\end{code}

\begin{code}{}
LoggingProxy>>>invocationCount
	^ invocationCount
\end{code}

理解されなかったすべてのメッセージを、単純にインターセプトし、それらをトランスクリプトに表示し、メッセージ数(\ct!invocationCount!)を更新し、そして、そのメッセージをプロキシーの実体へ転送します。
\begin{code}{}
LoggingProxy>>>doesNotUnderstand: aMessage 
	Transcript show: 'performing ', aMessage printString; cr.
	invocationCount := invocationCount + 1.
	^ aMessage sendTo: subject
\end{code}

ここで、ちょっとした魔法がやって来ます。
\ct{Point}オブジェクトと\ct{LoggingProxy}オブジェクトを新規に生成し、プロキシーに、「\ct{Point}オブジェクトに\mthind{ProtoObject}{become:}せよ」、と告げます。
\seeindex{\ct{become:}}{\ct{ProtoObject>>>become:}}
\begin{code}{}
point := 1@2.
LoggingProxy new !\underline{become:}! point.
\end{code}

\ct!become:!により、仮想イメージの中の、この\ct{Point}オブジェクトへのすべての参照を、プロキシーへの参照とスワップし、逆に、このプロキシーへのすべての参照を、\ct{Point}オブジェクトへの参照とスワップできます。最も重要なことですが、プロキシーの\ct{subject}インスタンス変数は、\ct{Point}オブジェクトを参照することになります!

\begin{code}{}
point invocationCount --> 0
point + (3@4)             --> 4@6
point invocationCount --> 1
\end{code}

これは、多くの場合、うまく働きますが、いくつか欠点もあります:
\begin{code}{}
point class --> LoggingProxy
\end{code}
奇妙なことに、\ct{class}メソッドは、\ct{ProtoObject}で実装されていないばかりか、\ct{Object}で実装されている\ct{class}メソッドとも違います。\ct{LoggingProxy}は、\ct{Object}を継承していません!
この謎に対する答えは、\ct{class}はメッセージとして送られるのではなく、仮想マシンによって直接処理されるということです。\footnote{\ct{yourself}もまた、本当は、決して送られません。
レシーバーが何であるかによって、直接仮想マシンが解釈することもありうるメッセージには、以下のものがあります:
\ct{+- < > <= >= = ~= * / \ ==}
\ct{@ bitShift: // bitAnd: bitOr:}
\ct{at: at:put: size}
\ct{next nextPut: atEnd}
\ct{blockCopy: value value: do: new new: x y}
以下のセレクターは、決して送られません。なぜなら、これらはコンパイラーによって、比較とジャンプのバイトコードにインライン展開されるからです:
\ct{ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:}
\ct{and: or:}
\ct{whileFalse: whileTrue: whileFalse whileTrue}
\ct{to:do: to:by:do:}
\ct{caseOf: caseOf:otherwise:}
\ct{ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:}
これらのメッセージを、非論理値オブジェクトに送ろうとしたとき、レシーバーのクラスで、\ct{mustBeBoolean}が定義されていれば、それらのメッセージ送信をインターセプトし、妥当な論理値でもって実行を再開できます。さもなくば、\ct{NonBooleanReceiver}例外をキャッチできます。
}% NB: Notes by Lukas Renggli

このような特別なメッセージ送信については、これを無視できるとしても、このアプローチでは、まだひとつ克服できない根本的な問題があります: \self-送信は、インターセプトできません:
\begin{code}{}
point := 1@2.
LoggingProxy new become: point.
point invocationCount --> 0
point rect: (3@4)        --> 1@2 corner: 3@4
point invocationCount --> 1
\end{code}

\ct{LoggingProxy}は、\ct{rect:}メソッドの中の、ふたつの\self-送信を、数え損なっています:
\begin{code}{}
Point>>>rect: aPoint 
	^ Rectangle  origin: (self min: aPoint) corner: (self max: aPoint)
\end{code}

このプロキシーのテクニックを使えば、メッセージをインターセプトできますが、プロキシーを使うときは、それ特有の制限に注意するべきです。\secref{wrapper}では、メッセージをインターセプトするための、他の、より一般的なアプローチを見ていきます。

%-----------------------------------------------------------------
\subsection{欠けているメソッドの生成}

理解されなかったメッセージをインターセプトすることの応用例として、最も一般的なもうひとつのものは、欠けているメソッドの動的なロードもしくは、動的な生成です。
多くのメソッドからなる非常に大きなクラスライブラリについて考えてください。ライブラリ全体をロードするかわりに、各クラスのスタブをライブラリにロードできるはずです。スタブは、どこを探せば、これらのすべてのメソッドのソースコードが見つかるか、知っています。スタブは、単に、理解されなかったすべてのメッセージを捕捉し、そして、欠けているメソッドを、オンデマンドで動的にロードします。ある時点で、この振る舞いは解除でき、そしてロードされたコードは、クライアントアプリケーションの必要最小限のサブセットとして保存できます。

%\on{Stef sez: check ObjectOut -- I looked, but this seems to be very old. Depends on SqueakPage.}

このテクニックの単純な一形態を見てみましょう。これは、オンデマンドで、自動的に、インスタンス変数へのアクセサーを追加するクラスです:
% \lr{the last statement should return the result of the message, otherwise you cannot proceed with the debugger} \alex{all redefinition of doesNotUnderstand: includes a return statement. However, I do not see your comment lukas, I tried to insert a 'self halt' in the method, I was able to proceed. I added the return in the function} \lr{Of course it depends on the exact circumstances. If you perform a message on self that returns self it does not matter, but in any other case a forgotten return can introduce strange side effects. There was no return in the listing below, but now there is and the problem is solved.}

\begin{code}{}
DynamicAcccessors>>>doesNotUnderstand: aMessage
	| messageName |
	messageName := aMessage selector asString.
	(self class instVarNames includes: messageName)
		ifTrue: [
			self class compile: messageName, String cr, ' ^ ', messageName.
			^ aMessage sendTo: self ].
	^ super doesNotUnderstand: aMessage
\end{code}
理解されなかったメッセージはすべて、ここで捕捉されます。もし、送られたメッセージと同じ名前のインスタンス変数があったら、\ct{DynamicAcccessors}に、動的に生成したその変数へのアクセサーのソースコードをコンパイルするように依頼します。そして、メッセージを再送信します。

\ct{DynamicAccessors}クラスに、(初期化されていない)インスタンス変数\ct{x}があったにもかかわらず、事前に\ct{x}へのアクセサーが定義されていなかったとしましょう。すると以下のようにして、アクセサーが動的に生成され、そして\ct{x}の値が取り出されます。:
\needlines{2}
\begin{code}{}
myDA := DynamicAccessors new.
myDA x --> nil
\end{code}

\ct{DynamicAccessors}オブジェクトに最初に\ct{x}メッセージが送られたとき、何が起きるか、ひとつずつ見て行きましょう(\figref{DynamicAccessors}参照)。

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{DynamicAccessors}
	\caption{アクセサーの動的作成。\figlabel{DynamicAccessors}}
	% \alex{not sure whether the figure is highly necessary. The code is rather simple and the figure complete to follow in my opinion.}}
	% \on{trust me, it is useful to see all the steps.}
\end{figure}

(1) \ct{x}を\ct{myDA}に送り、(2) メッセージがクラスの中で検索され、そして、(3) クラス階層の中で見つかりません。(4) これにより、\ct{self doesNotUnderstand: #x}が、\ct{DynamicAccessors}オブジェクトに送り返され、(5) これが引き金になって、新しく検索が行われます。今度は、\ct{doesNotUnderstand:}が、ただちに\ct{DynamicAccessors}内に見つかり、(6) そして、\ct{DynamicAccessors}クラスが、文字列\ct{'x ^ x'}をコンパイルするように要求されます。\ct{compile}メソッドが検索され、(7)、そして(8) 最終的に\ct{Behavior}クラスに\ct{compile}メソッドが見つかり、それが(9-10) コンパイル済みメソッドを\ct{DynamicAccessors}のメソッド辞書に追加します。最後に、(11-13) メッセージが再送され、今度は、対応するメソッドが見つかります。

同じテクニックは、インスタンス変数のセッターや、他の種類の定型的なコード、Visitorパターンのvisitメソッドなど、を生成するのに使えます。

ステップ(13)での、\clsmthind{Object}{perform:}使い方に注意してください。\ct{perform:}メソッドを使えば、実行時に生成されたシンボルを使って、メッセージを送れます:
\begin{code}{@TEST}
5 perform: #factorial                                             --> 120
6 perform: ('fac', 'torial') asSymbol                       --> 720
4 perform: #max: withArguments: (Array with: 6) --> 6
\end{code}

%======================================
\section{メソッドラッパーとしてのオブジェクト}
\seclabel{wrapper}

すでに見てきたように、コンパイル済みメソッドも、\st においては、普通のオブジェクトです。そしてコンパイル済みメソッドオブジェクトにも、数々のリフレクティブなメソッドがあって、これらにより、プログラマーは、実行時システムにクエリを送れます。
少し意外かもしれませんが、\emph{任意のオブジェクト}は、コンパイル済みメソッドの役割を担うことができます。それには、\ct{run:with:in:}メソッドを実装し、他のいくつかの重要なメッセージに応答するだけで済みます。

\dothis{\ct{Demo}という空のクラスを定義しましょう。そして、\ct{Demo new answer42}を評価して、いつもの``Message Not Understood''エラーが引き起されることを確認しましょう。}

ここで、普通の\st のオブジェクトを、この\ct{Demo}クラスのメソッド辞書にインストールしましょう。

\dothis{\lct{Demo methodDict at: \#answer42 put: ObjectsAsMethodsExample new.}を評価しましょう。
ここで、もういちど\ct{Demo new answer42}の結果をprintしてみましょう。今度は、\ct{42}という答えが得られます。}

\clsind{ObjectsAsMethodsExample}クラスを見ると、以下のメソッドが見つかるはずです:
%\alex{I would prefer having return 42 in the run:with:in: method, and not having answer42 defined in ObjectsAsMethodsExample, this could be confusing I imagine}
%\on{ObjectsAsMethodsExample is part of the standard pharo image -- it is not in PBE-Reflection}
\needlines{5}
\begin{code}{}
answer42
	^42

run: oldSelector with: arguments in: aReceiver
	^self perform: oldSelector withArguments: arguments
\end{code}

この\ct{Demo}のインスタンスが\ct{answer42}メッセージを受け取ると、メソッド検索は通常どおりに始まります。しかし、仮想マシンは、コンパイル済みメソッドがあるべき場所に、普通の\st のオブジェクトを検出すると、それがメソッドの代わりを務めようとしている、と判断します。
仮想マシンは、\ct{ObjectsAsMethodsExample}オブジェクトに、\ct{run:with:in:}というメッセージを送ります。このとき、もともとのメソッドセレクターと、もともとの引数と、もともとのレシーバーが、\ct{run:with:in:}の引数になります。
\ct{ObjectsAsMethodsExample}は、この\ct{run:with:in:}メソッドを実装しているので、これはメッセージをインターセプトして、自分自身にメッセージを移譲します。

ここで、この偽のメソッドを削除するには、以下のようにします:
\begin{code}{}
Demo methodDict removeKey: #answer42 ifAbsent: []
\end{code}

\ct{ObjectsAsMethodsExample}をより詳しく見ると、そのスーパークラスがまた、\ct{flushcache}、\ct{methodClass:}、そして\lct{selector:}といったメソッドを定義しており、しかし、それらはすべて空になっていることがわかります。これらのメッセージは、コンパイル済みメソッドに送られる可能性があるので、コンパイル済みメソッドを装うオブジェクトは、以上のメソッドを実装していなければいけません。(実装すべき最も重要なメソッドは\ct{flushcache}で; 他のメソッドは、場合によって必要となる可能性があります。つまり、そのメソッドが\clsmthind{Behavior}{addSelector:withMethod:}を使ってインストールされたのか、あるいは、\clsmthind{MethodDictionary}{at:put:}を使って直接インストールされたのかという場合によってです)。

%-------------------------------------------------------------------------
\subsection{メソッドラッパーをカバレッジテストに使う}

メソッドラッパーは、メッセージをインターセプトするための、よく知られたテクニックです\cite{Bran98a}。
もともとの実装\footnote{http://www.squeaksource.com/MethodWrappers.html}では、メソッドラッパーとして、\ct{CompiledMethod}のサブクラスのインスタンスを使います。インストールされると、メソッドラッパーは、もともとのメソッドを呼び出す前かあとに、特別なアクションを実行できます。
アンインストールされると、もともとのメソッドは、メソッド辞書内の、本来あるべき位置に戻されます。

Pharoでは、\ind{メソッドラッパー}は、より簡単に実装できます。\ct{CompiledMethod}のサブクラスを作る代わりに、\ct{run:with:in:}を実装すればいいのです。実際、オブジェクトによるメソッドラッパーの、軽量の実装\footnote{http://www.squeaksource.com/ObjectsAsMethodsWrap.html}が存在します。しかし、これを書いている時点では、この実装は、標準のPharoの一部ではありません。

にもかかわらず、Pharoのテストランナーは、テストカバレッジを評価するのに、まさにこのテクニックを使っています。
テストランナーがどのように動作するか、ザッと見てみましょう。

テストカバレッジのエントリーポイントは、\clsmthind{TestRunner}{runCoverage}です:
\begin{code}{}
TestRunner>>>runCoverage
	| packages methods |
	... "カバレッジを測定するメソッドを識別する"
	self collectCoverageFor: methods
\end{code}

この\clsmthind{TestRunner}{collectCoverageFor:}メソッドは、カバレッジチェックのアルゴリズムを、明瞭に説明しています:
\begin{code}{}
TestRunner>>>collectCoverageFor: methods
	| wrappers suite |
	wrappers := methods collect: [ :each | TestCoverage on: each ].
	suite := self
		reset;
		suiteAll.
	[ wrappers do: [ :each | each install ].
	  [ self runSuite: suite ] ensure: [ wrappers do: [ :each | each uninstall ] ] ] valueUnpreemptively.
	wrappers := wrappers reject: [ :each | each hasRun ].
	wrappers isEmpty 
		ifTrue: 
			[ UIManager default inform: 'Congratulations. Your tests cover all code under analysis.' ]
		ifFalse: ...
\end{code}
チェックする各メソッドについて1個ずつラッパーが作られ、そして、各ラッパーがインストールされます。
テストが実行され、すべてのラッパーはアンインストールされます。
最後に、テストされなかったメソッドについてのフィードバックが、得られます。

ラッパーそれ自身は、どのように動くのでしょうか?
次の\ct{TestCoverage}ラッパーには、3個のインスタンス変数: \ct{hasRun}、\ct{reference}、\ct{method}があります。
これらは以下のように初期化されます。
\begin{code}{}
TestCoverage class>>>on: aMethodReference
	^ self new initializeOn: aMethodReference

TestCoverage>>>initializeOn: aMethodReference
	hasRun := false.
	reference := aMethodReference.
	method := reference compiledMethod
\end{code}

installメソッドと、uninstallメソッドは、自明な方法で、メソッド辞書を更新します:
\begin{code}{}
TestCoverage>>>install
	reference actualClass methodDictionary
		at: reference methodSymbol
		put: self

TestCoverage>>>uninstall
	reference actualClass methodDictionary
		at: reference methodSymbol
		put: method
\end{code}
\noindent
そして、\ct{run:with:in:}メソッドは、単に、\ct{hasRun}インスタンス変数を更新し、ラッパーをアンインストールし(カバレッジが検証されたから)、もともとのメソッドにメッセージを再送します。
\begin{code}{}
run: aSelector with: anArray in: aReceiver
	self mark; uninstall.
	^ aReceiver withArgs: anArray executeMethod: method

mark
	hasRun := true
\end{code}
(\clsmthind{ProtoObject}{withArgs:executeMethod:}を見てみましょう。そして、メソッド辞書から取り除かれていたメソッドが、どのように呼び出されるか、見てみましょう。)

ただそれだけです。

メソッドラッパーを使えば、あらゆる種類の振る舞いを(それが適切であれば)、通常のメソッドの操作の前かあとに実行させられます。典型的な応用例は、インストゥルメンテーション(メソッドの呼び出しパターンに関する統計を収集すること)、オプションで、事前・事後条件をチェックすること、メモ化(オプションで、メソッドが計算した値をキャッシュすること)です。

%======================================
\section{プラグマ}

\emphind{プラグマ}は、プログラムについてのデータを明記するアノテーション(注釈)ですが、プログラムの実行には関与しません。プラグマは、プラグマがアノテートするメソッドの操作に、直接影響しません。
プラグマには、いくつもの使い道があります、それらは、例えば以下のようなものです:
\begin{itemize}
\item コンパイラーへの情報: \indmain{プラグマ}は、コンパイラがメソッド呼び出しをプリミティブ関数にするのに用いられます。このプリミティブ関数は、仮想マシンか外部プラグインが定義しなければなりません。
\item 実行時処理: いくつかのプラグマは、実行時にこれを検査できます。
\end{itemize}

プラグマが適用可能なのは、プログラムのメソッド宣言においてのみです。メソッドは、1個かそれ以上のプラグマを宣言でき、そしてプラグマは、どのSmalltalkの文よりも先に宣言されなければなりません。各プラグマは、事実上、リテラル引数をともなった静的メッセージ送信です。

この章の前の方でプリミティブを紹介したときに、簡単なプラグマの例を見ました。プリミティブは、プラグマ宣言以上の何物でもありません。
\ct{instVarAt:}メソッドの定義内の\ct{<primitive: 73>}を検討してください。このプラグマのセレクターは、\ct{primitive:}であり、その引数はリテラル値で、\ct{73}です。

コンパイラーはおそらく、プラグマの大口ユーザです。SUnitもまた、アノテーションを活用するツールです。SUnitは、テストユニットからアプリケーションのカバレッジを見積れます。SUnitでは、いくつかのメソッドを、カバレッジから除外したいと思うかもしれません。以下は、\ct!SplitJointTest class!の\ct!documentation!メソッドの場合です:

\begin{code}{}
SplitJointTest class>>>documentation
	<ignoreForCoverage>
	"self showDocumentation"
	
	^ 'This package provides function.... "
\end{code}

単に、メソッドを\ct!<ignoreForCoverage>!プラグマでアノテートするだけで、カバレッジのスコープをコントロールできます。

%Beside the compiler, Lint is a heavy user of pragmas. Lint is a static code analyzer that flags suspicious, non-portable constructs and code that is likely to contain bugs. It may happen that a method needs to be excluded from Lint analysis. This is the case here:

%\begin{code}{}
%MorphObjectOut>>>doesNotUnderstand: aMessage 
%	"Bring in the object, install, then resend aMessage"
%	"Transcript show: thisContext sender selector; cr."
%	"useful for debugging"
%	
%	! \textbf{<lint: 'Unnecessary "= true"' rationale: 'recursionFlag may be nil' author: 'stephane.ducasse'>}!
%	...
%\end{code}	

%One of the pragmas used by Lint to filter out methods is \ct{lint:rationale:author:}.

プラグマは、\clsind{Pragma}のインスタンスであって、ファーストクラスのオブジェクトです。コンパイル済みメソッドは、\mthind{CompiledMethod}{pragmas}メソッドを実装します。\ct!pragmas!メソッドは、プラグマの配列を返します。

\begin{code}{}
(SplitJoinTest class >> #showDocumentation) pragmas.
  --> an Array(<ignoreForCoverage>)
(Float>>#+) pragmas --> an Array(<primitive: 41>)
\end{code}

特定のクエリを定義するメソッドが、クラスから取り出されることがあり得ます。\ct!SplitJoinTest!のクラス側には、\ct!<ignoreForCoverage>!とアノテートされた、いくつかのメソッドがあります:

\begin{code}{@TEST}
Pragma allNamed: #ignoreForCoverage in: SplitJoinTest class  --> an Array(<ignoreForCoverage> <ignoreForCoverage> <ignoreForCoverage>)
\end{code}

\ct{allNamed:in:}の変種が、\ct{Pragma}のクラス側に見付かるでしょう。

プラグマは、どのメソッドの中で、そのプラグマが定義されたか知っていおり(\ct{method}を使えばわかります)、そのメソッドの名前を(\ct{selector})、そのメソッドを含むクラスを(\ct{methodClass})、プラグマの引数の数を(\ct{numArgs})、プラグマに特定の引数リテラルがあるかどうかを(\ct{hasLiteral:}と\ct{hasLiteralSuchThat:})知っています。

\lr{Typically pragmas are performed on an interpreter object that understands the pragma message.}

%======================================
\section{章のまとめ}

リフレクションと言った場合、それは、実行時システムのメタオブジェクトについて、これにクエリを送れたり、これを検査できたり、これを変更さえできたりすることを指します。こうした点で、メタオブジェクトは、普通のオブジェクトと同等です。

\begin{itemize}
\item インスペクターは、\ct{instVarAt:}や、これに関連するメソッドを用いて、オブジェクトの「プライベートな」インスタンス変数にクエリを送ったり、これを変更したりします。
\item 与えられたクラスのすべてのインスタンスを知りたければ、\ct{Behavior>>>allInstances}をそのクラスに送りましょう。
\item \ct{class}、\ct{isKindOf:}、\ct{respondsTo:}\etc メソッドは、メトリクスを収集したり、開発ツールを構築するのには便利ですが、通常のアプリケーションでは、これらは避けるべきです: これらのメソッドはオブジェクトのカプセル化の原則に反し、コードを理解しづらく、保守しづらいものにします。
\item \ct{SystemNavigation}はユーティリティークラスであって、クラス階層をナビゲートし、ブラウズするのに、便利なクエリを備えています。例えば、与えられた文字列をソースコードに含む、すべてのメソッドを見つけ出すには、\ct{SystemNavigation default browseMethodsWithSourceString: 'pharo'.}を使いましょう。(遅いですが、完全な検索方法です!)
\item どの \st のクラスにも、\ct{MethodDictionary}があって、この辞書は、セレクターとコンパイル済みメソッドのインスタンスを対応づけています。コンパイル済みメソッドは、そのクラスを知っています。こうして、両者はお互いを知っていることになります。
\item \ct{MethodReference}は、コンパイル済みメソッドの軽量プロキシーです。\ct{MethodReference}は、追加の簡易メソッドを提供するもので、多くの\st のツールが、この\ct{MethodReference}を使っています。
\item \ct{BrowserEnvironment}、これはリファクタリングブラウザーのインフラの一部ですが、これを使えば、\ct{SystemNavigation}より洗練されたインターフェースを通して、システムにクエリを送れます。これは、クエリの結果が、次の新しいクエリのスコープとして使えるからです。\ct{BrowserEnvironment}では、GUIによるインターフェースとプログラム的なインターフェースの両方が利用できます。
\item \ct{thisContext}は疑似変数です。この疑似変数は、仮想マシンの実行時スタックを具現化したものです。\ct{thisContext}は、主にデバッガーで使われ、スタックに対する会話的なビューを動的に構築するのに使われます。\ct{thisContext}はまた、メッセージのセンダーを動的に特定したい場合に、とりわけ便利です。
\item \ct{haltIf:}を使えば、賢いブレークポイントを設定できます。このとき、メソッドセレクターを、\ct{haltIf:}の引数にします。\ct{haltIf:}は、その引数のシンボルと一致するメソッドが、センダーとして、実行時スタック内に現われたときのみ、停止します。
\item 一般的には、与えられたターゲットに送られるメッセージをインターセプトするには、「最小限のオブジェクト」を使います。最小限のオブジェクトは、ターゲットのプロキシーとして使います。プロキシーで実装するメッセージは、できるだけ少なくします。そして、\ct{doesNotunderstand:}を実装して、すべてのメッセージ送信を捕捉します。こうすれば、いくつかの追加のアクションを実行してから、もともとのターゲットにメッセージを転送できます。
\item プロキシーとそのターゲットのような、ふたつのオブジェクトへの参照を交換するには、\ct{become:}を使いましょう。
\item 注意してください。いくつかのメッセージ、例えば\ct{class}や\ct{yourself}は、決して実際には送られず、代わりに、仮想マシンによって解釈されます。他の、例えば、\ct{+}, \ct{-} and \ct{ifTrue:} も、直接仮想マシンによって解釈されるか、インライン展開されます。このようなことが起こるかどうかは、レシーバーによって異なります。
\item \ct{doesNotUnderstand:}をオーバーライドする、他の典型的な例は、欠けているメソッドの遅延ロードまたは、遅延コンパイルです。
\item \ct{doesNotUnderstand:}は、\self-送信を捕捉できません。
\item オブジェクトをメソッドラッパーとして使えば、より厳密な意味で、メッセージをインターセプトできます。このようなラッパーは、メソッド辞書内の、本来ならコンパイル済みメソッドが格納されるべき場所にインストールされます。メソッドラッパーは、\ct{run:with:in:}を実装しなければなりません。このメッセージは、仮想マシンが、メソッド辞書内で、コンパイル済みメソッドの代わりに普通のオブジェクトを検出したときに送られます。このテクニックは、SUnitテストランナーが、カバレッジデータを集めるのに使われています。
\end{itemize}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%Other stuff:
%- anonymous classes (uses compile: and primitiveChangeClassTo:) ???
%- collect direct senders; class collaborations
%- Object primitiveChangeClassTo: become: and becomeForward: (see tests and slides with minimal object example)
%- PointerFinder?
%- anonymous classes (see slides) ?

%Test  Coverage using ObjectsAsMethodsWrap package:
%\begin{code}{}
%category := 'SCGPier'.
%w := (ObjectAsOneTimeMethodWrapper installOnClassCategory: category).
%tr := TestRunner new.
%ToolBuilder open: tr.
%[tr
%	categoryAt: (tr categoryList indexOf: 'SCGPier') put: true;
%	selectAllClasses;
%	runAll.]
%ensure: [[w do: [:each| each uninstall ]] valueUnpreemptively].
%((w select: [:each | each executed not ])
%	collect: [:each | each wrappedClass name, '>>', each selector name ]) explore.
%\end{code}

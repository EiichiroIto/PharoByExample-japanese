% $Author$
% $Date$
% $Revision$

% HISTORY:
% 2006-10-24 - Stef started
% 2006-10-25 - Stef first draft
% 2006-12-07 - Andrew edit
% 2007-06-13 - Andrew revised
% 2007-06-21 - Oscar edit
% 2007-07-26 - Stef review
% 2007-08-23 - Oscar review
% 2007-08-29 - Andrew corrections

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
% \chapter{The \st object model}
\chapter{\stオブジェクトモデル}
\chalabel{model}

% \st's programming model is simple and uniform: everything is an object, and objects communicate only by sending each other messages.
\stのプログラミングモデルは簡潔で一貫しています： 全てのものはオブジェクトで、オブジェクトはメッセージをお互いに送ることによってのみやりとりをします。
% However, this simplicity and uniformity can be a source of difficulty for programmers used to other languages. In this chapter we present the core concepts of the \st object model; in particular we discuss the consequences of representing classes as objects.
しかしながら、この簡潔さと一貫性が、他の言語に慣れたプログラマにとって難しさの元になっています。
この章では、\stのオブジェクトモデルの中心概念を示します。特に、クラスをオブジェクトとして表現することが何をもたらすのかを議論します。

%=========================================================
% \section{The rules of the model}
\section{モデルの規則}
\seclabel{rules}

% The \st object model is based on a set of simple 
% rules that are applied \emph{uniformly}. The rules are as follows:
\stのオブジェクトモデルは、以下の一連の簡潔な規則に基いていて、規則は一貫して適用されます。

\begin{enumerate}[label={\textbf{Rule \arabic{*}}.}, ref={Rule \arabic{*}}, leftmargin=*]
\item{} \rulelabel{everything}
%	Everything is an object.
	全てのものはオブジェクトである。

\item{} \rulelabel{instance}
%	Every object is an instance of a class.
	全てのオブジェクトはクラスのインスタンスである。

\item{}  \rulelabel{inheritance}
%	Every class has a superclass.
	全てのクラスはスーパークラスを持っている。

\item{}  \rulelabel{message}
%	Everything happens by sending messages.
	全てのことは、メッセージを送ることで起こる。

\item{}  \rulelabel{lookup}
%	Method lookup follows the inheritance chain.
	メソッド探索は継承の連鎖を辿る。

\end{enumerate}

\noindent
%Let us look at each of these rules in some detail.
では、これらの規則を1つ1つ詳細に見ていきましょう。


%=========================================================
% \section{Everything is an Object}
\section{全てのものはオブジェクトである}

%\ruleref{everything}

% The mantra ``everything is an object'' is highly contagious.
「全てのものはオブジェクトである」という信念は、感染力が高いものです。
% After only a short while working with \st, you will start to be surprised at how this rule simplifes everything you do.
ほんの短い間\stを使っただけで、この規則がいかに物事を簡単にするのか、驚きはじめるでしょう。
% Integers, for example, are truly objects, so you can send messages to them, just as you do to any other object.
例えば、整数も本物のオブジェクトで、他のあらゆるオブジェクトと同様、整数にもメッセージを送ることができます。

\begin{code}{@TEST}
3 + 4            --> 7    "'+ 4'を3に送ることで, 結果として7が得られます"
20 factorial  --> 2432902008176640000   "factorialを送ると, 大きな数が得られます"
\end{code}

% The representation of \ct{20 factorial} is certainly different from the representation of \ct{7}, but because they are both objects, none of the code\,---\,not even the implementation of \ct{factorial}\,---\,needs to now about this.
\ct{20 factorial}の内部表現と\ct{7}の内部表現は実際には異なっていますが、それらはどちらもオブジェクトなので、実際のコード --- \ct{factorial}の実装ですら --- その内部表現を知る必要はありません。

\needlines{3}
% Perhaps the most fundamental consequence of this rule is the following:
おそらくこの規則の一番根本的な帰結は以下のものです。
% \important{Classes are objects too.}
\important{クラスもオブジェクトである。}
% Furthermore, classes are not second-class objects: they are really first-class objects that you can send messages to, inspect, and so on.
もっと言えば、クラスは第二級のオブジェクトではありません。クラスは本当にファーストクラスオブジェクトで、メッセージを投げたりインスペクトしたりすることができます。
%This means that \pharo is a truly reflective system, which gives a great deal of expressive power to developers.
つまり\pharoは本当の意味でリフレクティブなシステムだということで、このことが開発者に非常に強力な表現力を与えています。

% Deep in the implementation of \st, there are three different kinds of objects.  There are (1) ordinary objects with instance variables that are passed by references, there are (2) \emph{small integers} that are passed by value, and there are (3) indexable objects like arrays that hold a contiguous portion of memory.  The beauty of \st is that you normally don't need to care about the differences between these three kinds of object.
\stの実装の深いところでは、3つの種類のオブジェクトがあります。(1)インスタンス変数を持ち、参照で渡される通常のオブジェクト、(2)値で渡される\emph{小さな整数}、(3)配列のように連続したメモリ領域を持つインデックス付オブジェクトです。\stの美しさは、これら3種類のオブジェクトの違いについて通常は気にする必要がないところです。

%=========================================================
% \section{Every object is an instance of a class}
\section{全てのオブジェクトはクラスのインスタンスである}

%\ruleref{instance}

% Every object has a class; you can find out which by sending it the message \ct{class}.
全てのオブジェクトはクラスを持っています。オブジェクトに\ct{class}メッセージを送ることで見ることができます。

\begin{code}{@TEST}
1 class                 --> SmallInteger
20 factorial class --> LargePositiveInteger
'hello' class          --> ByteString
#(1 2 3) class       --> Array
(4@5) class         --> Point
Object new class --> Object
\end{code}

% A class defines the \emph{structure} of its instances via instance variables,
クラスはインスタンス変数を通してインスタンスの\emph{構造}を定義します。
% and the \emph{behavior} of its instances via methods.
そしてメソッドを通してインスタンスの\emph{振る舞い}を定義します。
% Each method has a name, called its \emphsubind{method}{selector}, which is unique within the class.
各メソッドは名前を持っていて、\emphsubind{メソッド}{セレクタ}と呼ばれています。名前はそのクラスの中でユニークです。

% Since \emph{classes are objects}, and \emph{every object is an instance of a class}, it follows that classes must also be instances of classes.
\emph{クラスはオブジェクトである}ことから、そして、{全てのオブジェクトはクラスのインスタンスである}ことから、クラスもまた、クラスのインスタンスであるということになります。
% A class whose instances are classes is called a \emphind{metaclass}.
クラスをインスタンスとするクラスは\emphind{メタクラス}と呼ばれます。
% Whenever you create a class, the system automatically creates a metaclass for you.
クラスを定義するたびに、システムは自動的にメタクラスを生成します。
% The metaclass defines the structure and behavior of the class that is its instance.
メタクラスは、インスタンスであるクラスの構造と振る舞いを定義します。
% 99\% \damien{Did any of you verify it is 99\%? Maybe 'Most' would have been better than '99\%'} of the time you will not need to think about metaclasses, and may happily ignore them.
99\% \damien{どなたか、本当に99\%だと確かめましたか？大抵のものは'99\%'よりも良いかもしれませんよ}の場合は、メタクラスについて考える必要はないでしょう。その場合は無視してくださって結構です。
% (We will have a closer look at metaclasses in \charef{metaclasses}.)
(\charef{metaclasses}でメタクラスについて詳しく見てみましょう。)
%---------------------------------------------------------
% \subsection{Instance variables}
\subsection{インスタンス変数}

% Instance variables in \st are private to the \emph{instance} itself.
\stではインスタンス変数は、その\emph{インスタンス}でプライベートです。
% This is in contrast to \ind{Java} and \ind{C++}, which allow instance variables (also known as ``fields'' or ``member variables'') to be accessed by any other instance that happens to be of the same class.
これは、\ind{Java}や\ind{C++}と対照的です。それらの言語では、インスタンス変数(``フィールド''とか``メンバ変数''とも呼ばれていますね)は同じクラスの他のインスタンスからのアクセスを許しています。
% We say that the \emphind{encapsulation boundary} of objects in Java and C++ is the class, whereas in \st it is the instance.
オブジェクトの\emphind{カプセル化の境界}がJavaやC++ではクラス、\stではインスタンスである、と言います。

\seeindex{Henn!instance}{インスタンス変数}
\seeindex{field}{インスタンス変数}
\seeindex{attribute}{インスタンス変数}
\seeindex{slot}{インスタンス変数}
\index{インスタンス変数}

% In \st, two instances of the same class cannot access each other's instance variables unless the class defines ``\ind{accessor} methods''.
\stでは、``\ind{アクセサ}メソッド''を定義しない限り、同じクラスの2つのインスタンスはお互いのインスタンス変数にアクセスすることはできません。
% There is no language syntax that provides direct access to the instance variables of any other object.
他のオブジェクトのインスタンス変数に直接アクセスするための言語構文がないのです。
% (Actually, a mechanism called \ind{reflection}
(実のところ、\charef{metaprog}で扱われる\ind{リフレクション}と呼ばれる機構が他のオブジェクトにインスタンス変数の値へのアクセスを提供しています。
%, discussed in \charef{metaprog},
% does provide a way to ask another object for the values of its instance variables; meta-programming is intended for writing tools like the object \ind{inspector}, whose sole purpose is to look inside other objects.)
メタプログラミングはオブジェクト\ind{インスペクタ}のようなツールを記述することを意図しています。インスペクタはオブジェクトの中身を見ることを目的にしたツールです。)
% Instance variables can be accessed by name in any of the instance methods of the class that defines them, and also in the methods defined in its subclasses. This means that \st instance variables are similar to \emph{protected} variables in C++ and Java. However, we prefer to say that they are private, because it is considered bad style in \st to access an instance variable directly from a subclass. 
インスタンス変数は、その変数を定義しているクラスのインスタンスメソッドから、名前でアクセスすることができます。
このことから、\stのインスタンス変数はC++やJavaの\emph{プロテクト}変数に似ていると言えます。しかしながら、やはりプライベートと読んだほうが好ましいでしょう。というのも、インスタンス変数をサブクラスからアクセスすることは、\stでは良くないスタイルと考えられているからです。

% \subsubsection{Example}
\subsubsection{例題}
% Method \cmind{Point}{dist:} (\mthref{dist:}) computes the distance between the receiver and another point. The instance variables \ct{x} and \ct{y} of the receiver are accessed directly by the method body.  However, the instance variables of the other point must be accessed by sending it the messages \ct{x} and \ct{y}.
\cmind{Point}{dist:} (\mthref{dist:})メソッドは、レシーバともう1つの点との間の距離を計算します。
レシーバのインスタンス変数\ct{x}と\ct{y}は、メソッドから直接アクセスされています。
しかし、もう1つの点は、\ct{x}メッセージや\ct{y}メッセージを送ることでアクセスしなければなりません。

\needlines{7}
\begin{method}[dist:]{the distance between two points}
Point>>>dist: aPoint 
	"Answer the distance between aPoint and the receiver."  
	| dx dy |
	dx := aPoint x - x.
	dy :=  aPoint y - y.
	^ ((dx * dx) + (dy * dy)) sqrt
\end{method}

\begin{code}{@TEST}
1@1 dist: 4@5 --> 5.0
\end{code}

% The key reason to prefer instance-based encapsulation to class-based encapsulation is that it enables different implementations of the same abstraction to coexist.
クラスベースのカプセル化ではなく、インスタンスベースのカプセル化を選択する決め手となったのは、インスタンスベースのカプセル化は同じ抽象の異なる実装を共存させることができるからです。
% For example, method \ct{point>>>dist:}, need not know or care whether the argument \ct{aPoint} is an instance of the same class as the receiver.  The argument object might be represented in polar coordinates, or as a record in a database, or on another computer in a distributed system; as long as it can respond to the messages \ct{x} and \ct{y}, the code in \mthref{dist:} will still work.
例えば、\ct{point>>dist:}メソッドは、引数\ct{aPoint}がレシーバと同じクラスなのかどうか知る必要もありませんし、気にする必要もないからです。
引数オブジェクトは極座標かもしれませんし、データベースのレコードかもしれませんし、分散システムの他の計算機上にあるかもしれません。
\ct{x}メッセージや\ct{y}メッセージに答えてくれる限り、\mthref{dist}のコードはちゃんと動作するでしょう。

%---------------------------------------------------------
% \subsection{Methods}
\subsection{メソッド}

% All methods are \subind{method}{public}.\footnote{Well, almost all.  In \pharo, methods whose selectors start with the string \ct{pvt} are private: a \ct{pvt} message can be sent \emph{only} to \self.  However, \ct{pvt} methods are not used very much.}
全てのメソッドは\subind{メソッド}{パブリック}です。\footnote{正確には、ほぼ全て、です。\pharoでは、\ct{pvt}で始まるセレクタを持つメソッドはプライベートで、\ct{pvt}メッセージは\selfに\emph{のみ}送ることができます。しかし、\ct{pvt}メソッドはあまり使われていません。}
% Methods are grouped into protocols that indicate their intent.
メソッドは、その目的に応じてプロトコルにグループ分けされています。
% Some common protocol names have been established by convention, for example, \protind{accessing} for all accessor methods, and \protind{initialization} for establishing a consistent initial state for the object.
共通して使われているプロトコルはコンベンションによって確立されてきました。例えば、\protind{accessing}はアクセサメソッドで、\protind{initialization}はオブジェクトの一貫した初期状態を確立するメソッドです。
% The protocol \protind{private} is sometimes used to group methods that should not be seen from outside.
\protind{private}プロトコルは、外から見られるべきでないメソッドとしてグループ分けするのに使われます。
% Nothing, however, prevents you from sending a message that is implemented by such a ``private'' method.
しかし、そういった``private''メソッドがあるからといって、実際にメッセージを送ることを防ぐことはできません。
% Methods can access all instance variables of the object.
メソッドはそのオブジェクトの全てのインスタンス変数にアクセスすることができます。
% Some \st developers prefer to access instance variables only through accessors.
\st開発者の中には、アクセサを通してのみインスタンス変数にアクセスすることを好む人もいます。
% This practice has some value, but it also clutters the interface of your classes, and worse, exposes private state to the world.
この取り組みには一定の価値がありますが、クラスのインターフェースを乱雑にしたり、もっと悪いことに、外部の世界にプライベートな状態を晒すことにもなります。

%---------------------------------------------------------
% \subsection{The instance side and the class side}
\subsection{インスタンス側とクラス側}

% Since classes are objects, they can have their own instance variables and their own methods.
クラスはオブジェクトなので、クラス自身のインスタンス変数やメソッドを持つことができます。
%We call these \emph{class instance variables} and \emph{class methods}, but they are really no different from ordinary instance variables and methods:
これらは\emph{クラスインスタンス変数}や\emph{クラスメソッド}と呼ばれていますが、実際のところ普通のインスタンス変数やメソッドと何も違いません。
%class instance variables are just instance variables defined by a metaclass, and class methods are just methods defined by a \ind{metaclass}. 
クラスインスタンス変数は単にメタクラスで定義されたインスタンス変数にすぎませんし、クラスメソッドは単に\ind{メタクラス}で定義されたメソッドにすぎません。
\index{クラス!インスタンス変数}
\seeindex{変数!クラスインスタンス}{クラス, インスタンス変数}
\index{クラス!メソッド}

% A class and its \ind{metaclass} are two separate classes, even though the former is an instance of the latter. 
クラスは\ind{メタクラス}のインスタンスですが、クラスとそのメタクラスは別々のクラスです。
% However, this is largely irrelevant to you as a programmer: you are concerned with defining the behavior of your objects and the classes that create them.
しかし、プログラマであるあなたにはおよそ関係ない話です。プログラマが気にかけることは、オブジェクトやそれを生成するクラスの振る舞いを定義することなのです。

\begin{figure}[htb]
\begin{center}
\includegraphics[width=\textwidth]{Color-Buttons}
% \caption{Browsing a class and its metaclass.
\caption{クラスとそのメタクラスをブラウズする。
% \sd{Do we use Key everywhere in the picture as a legend indicator?}
% \on{sure, wherever appropriate}
\figlabel{Buttons}}
\end{center}
\end{figure}

%For this reason, the browser \index{browser} helps you to browse both class and metaclass as if they were a single thing with two ``sides'': the ``\subind{browser}{instance side}'' and the ``\subind{browser}{class side}'', as shown in \figref{Buttons}.
このことから、ブラウザ\index{ブラウザ}は、クラスとメタクラスがあたかも1つのものの2つの側面であるかのように、クラスとメタクラスの両方をブラウズできるようになっています。\figref{Buttons}に示されている、``\subind{ブラウザ}{インスタンス側}''と\subind{ブラウザ}{クラス側}''です。
% Clicking  on the \button{instance} button browses the class \ct{Color}, \ie you browse the methods that are executed when messages are sent to an instance of \ct{Color}, like the blue color. 
\button{instance}ボタンをクリックすると、\ct{Color}クラスをブラウズします。つまり、例えば青色のような\ct{Color}のインスタンスにメッセージが送られた時に実行されるメソッドをブラウズします。
% Pressing the \button{class} button browses the class \ct{Color class}, \ie you see the methods that will be executed when messages are sent to the class \ct{Color} itself.
\button{class}ボタンを推すと、\ct{Color class}クラスをブラウズします。つまり、\ct{Color}クラス自体にメッセージが送られた時に実行されるメソッドを見ることになります。
% For example, \ct{Color blue} sends the message \ct{blue} to the class \clsind{Color}.
例えば、\ct{Color blue}は\ct{blue}メッセージを\clsind{Color}クラスに送ります。
% You will therefore find the method \ct{blue} defined on the class side of \ct{Color}, not on the instance side.
したがって、この\ct{blue}メッセージは\ct{Color}のクラス側に定義されています。インスタンス側ではありません。
\seeindex{class side}{browser!class side}
\seeindex{instance side}{browser!instance side}

\needlines{5}
\begin{code}{@TEST | aColor |}
aColor := Color blue.               "クラス側のblueメソッド"
aColor        --> Color blue
aColor red  --> 0.0         "インスタンス側のアクセサメソッドred"
aColor blue --> 1.0        "インスタンス側のアクセサメソッドblue"
\end{code}

% You define a class by filling in the template proposed on the \subind{browser}{instance side}.
\subind{ブラウザ}{インスタンス側}で提供されるテンプレートを埋めることでクラスを定義します。
% When you accept this template, the system creates not just the class that you defined, but also the corresponding metaclass.
このテンプレートをアクセプトすると、システムはそのクラスだけでなく、対応するメタクラスも生成します。
% You can browse the metaclass by clicking on the \button{class} button.
\button{class}ボタンをクリックするとメタクラスをブラウズできます。
% The only part of the metaclass creation template that makes sense for you to edit directly is the list of instance variable names.
メタクラス生成テンプレートで編集するのは、インスタンス変数のリストだけです。

% Once a class has been created, clicking the \button{instance} button lets you edit and browse the methods that will be possessed by instances of that class (and of its subclasses). For example, we can see in \figref{Buttons} that the method \ct{hue} is defined on instances of the class \ct{Color}.
一旦クラスが生成されると、\button{instance}ボタンをクリックすると、そのクラス(およびそのサブクラス)が持つことになるメソッドを編集したりブラウズしたりできます。例えば、\figref{Buttons}を見ると、\ct{hue}メソッドが\ct{Color}クラスのインスタンスに定義されています。
% In contrast, the \button{class} button lets you browse and edit the metaclass (in this case \ct{Color class}).
逆に、\button{class}ボタンでは、そのメタクラス(この場合、\ct{Color class})を

%---------------------------------------------------------
% \subsection{Class methods} 
\subsection{クラスメソッド} 

% Class methods can be quite useful; browse \ct{Color class} for some good examples.
クラスメソッドはとても便利なことがあります。\ct{Color class}をブラウズすると良い例がいくつか見つかります。
% You will see that there are two kinds of \subind{class}{method} defined on a class: those that create instances of the class, like \cmind{Color class}{blue} and those that perform a utility function, like \cmind{Color class}{showColorCube}.
クラスに定義された\subind{クラス}{メソッド}には2種類あります。\cmind{Color class}{blue}のように、そのクラスのインスタンスをつくるものと、\cmind{Color class}{showColorCube}のように、ユーティリティ的な機能を提供するものです。

% This is typical, although you will occasionally find class methods used in other ways.
他の用途に使われているクラスメソッドを見かけることもあるでしょうが、これが典型的な用法です。

% It is convenient to place utility methods on the \subind{browser}{class side} because they can be executed without having to create any additional objects first.
余計なインスタンスを生成することなく実行できるので、\subind{ブラウザ}{クラス側}にユーティリティ的なメソッドを置くと便利です。
% Indeed, many of them will contain a comment designed to make it easy to execute them.
実際、そういったユーティリティメソッドの多くは、簡単に実行できるコメントを含んでいます。

% \dothis{Browse method \ct{Color class>>>showColorCube}, double-click just inside the quotes on the comment \ct{"Color showColorCube"} and type \short{d}.}
\dothis{\ct{Color class>>>showColorCube}メソッドをブラウズして, コメント\ct{"Color showColorCube"}の引用符の内側をダブルクリックして、\short{d}を押してみてください。}
% You will see the effect of executing this method.  (Select \menu{World \go \ind{restore display}~(r)} to undo the effects.)
このメソッドを実行した効果がわかるでしょう。(\menu{World \go \ind{restore display}~(r)}を実行して、元に戻してください。)

% For those familiar with \ind{Java} and \ind{C++},  class methods may seem similar to static methods. 
\ind{Java}や\ind{C++}に慣れている人には、クラスメソッドは静的メソッドに似ているように見えるかもしれません。
% However, the uniformity of \st means that they are somewhat different: whereas Java static methods are really just statically-resolved procedures, \st class methods are dynamically-dispatched methods.  This means that inheritance, overriding and super-sends work for class methods in \st, whereas they don't work for static methods in Java.  
しかし、\stの一貫性から、いくぶんの違いがあります。
Javaの静的メソッドは本当に単に静的に名前解決される手続きに過ぎないのですが、\stのクラスメソッドは動的に探索されるメソッドです。つまり、\stではクラスメソッドを継承したりオーバーライドしたりsuperに送信したりできますが、Javaの静的メソッドではできません。

%---------------------------------------------------------
% \subsection{Class instance variables}
\subsection{クラスインスタンス変数}
% With ordinary instance variables, all the instances of a class have the same set of variable names, and the instances of its subclasses inherit those names; however, each instance has its own private set of values.
通常のインスタンス変数では、あるクラスの全てのインスタンスは同じ変数名のセットを持っていて、サブクラスのインスタンスはそれらの名前を継承します。しかし、各インスタンスはそれぞれのインスタンス自身にプライベートな値のセットを持ちます。
% The story is exactly the same with class \subind{class}{instance variable}{}s: each class has its own private class instance variables.
\subind{クラス}{インスタンス変数}{}も全く同様です。各クラスはそれぞれ自身にプライベートなクラスインスタンス変数を持っています。
% A subclass will inherit those class instance variables, \emph{but it has its own private copies of those variables}.
サブクラスはそれらのクラスインスタンス変数を継承しますが、\emph{サブクラスはそれ自身にプライベートなコピーのクラスインスタンス変数を持っています。}
% Just as objects don't share instance variables, neither do classes and their subclasses share class instance variables.
オブジェクトがインスタンス変数を共有しないのと同様に、クラスとサブクラスもクラスインスタンス変数を共有しません。

% You could use a class instance variable called \ct{count} to keep track of how many instances you create of a given class.
あるクラスについて生成したインスタンスの数を管理するために\ct{count}というクラスインスタンス変数を使うことはできますが、
% However, any subclass would have its own \ct{count} variable, so subclass instances would be counted separately.
そのサブクラスはどれも自分自身の\ct{count}変数を持っているので、サブクラスのインスタンスの数は別々に数えられることになります。

% \paragraph{Example: class instance variables are not shared with subclasses.}
\paragraph{例題: クラスインスタンス変数はサブクラスと共有されない。}
% Suppose we define classes \ct{Dog} and \ct{Hyena}, where \ct{Hyena} inherits the class instance variable \ct{count} from \ct{Dog}.
2つのクラス\ct{Dog}(犬)と\ct{Hyena}(ハイエナ)を定義します。\ct{Hyena}は\ct{Dog}からクラスインスタンス変数\ct{count}を継承します。

%\begin{classdef}[dog]{Dogs and Hyenas}
\begin{classdef}[dog]{犬とハイエナ}
Object subclass: #Dog
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-CIV'

Dog class
	instanceVariableNames: 'count'

Dog subclass: #Hyena
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-CIV'
\end{classdef}

% Now suppose we define class methods for \ct{Dog} to initialize its \ct{count} to \ct{0}, and to increment it when new instances are created:
さあ、\ct{Dog}の\ct{count}を\ct{0}に初期化するクラスメソッドと、新しいインスタンスが生成されたら1を足すクラスメソッドを定義しましょう：
% \begin{method}[dogcount]{Keeping count of new dogs}
\begin{method}[dogcount]{新しい犬の数を数える}
Dog class>>>initialize
	super initialize.
	count := 0.

Dog class>>>new
	count := count +1.
	^ super new

Dog class>>>count
	^ count
\end{method}

% Now when we create a new \ct{Dog} its count is incremented, and so is that of every \ct{Hyena}, but they are counted separately:
これで、新しい\ct{Dog}(犬)が生成されるたびに、頭数に1が足されていきます。\ct{Hyena}(ハイエナ)も同様ですが、別々に数えられていきます：
\begin{code}{}
Dog initialize.
Hyena initialize.
Dog count     --> 0
Hyena count --> 0
Dog new.
Dog count     --> 1
Dog new.
Dog count     --> 2
Hyena new.
Hyena count --> 1
\end{code}
% ON: In order to make this a test, I need the previous code to be part of the setup. Bleh.

% Note also that class instance variables are private to a class in exactly the same way that instance variables are private to the instance.
インスタンス変数がインスタンスごとにプライベートなのと同様に、クラスインスタンス変数はクラスごとにプライベートだということにも注意してください。
% Since classes and their instances are different objects,
クラスとそのインスタンスは別々のオブジェクトなことから、
% this has the following immediate consequences:
以下のことが言えます。
% \important{A class does not have access to the instance variables of its own instances.}
\important{クラスはそのインスタンスのインスタンス変数にアクセスすることはできない。}
% \important{An instance of a class does not have access to the class instance variables of its class.}
\important{クラスのインスタンスは、そのクラスのクラスインスタンス変数にアクセスすることはできない。}
% For this reason, instance initialization methods must always be defined on the \subind{browser}{instance side}\,---\,the \subind{browser}{class side} has no access to instance variables, so cannot initialize them!  
このことから、インスタンスを初期化するメソッドは常に\subind{ブラウザ}{インスタンス側}で定義しなければなりません --- \subind{ブラウザ}{クラス側}からはインスタンス変数にアクセスできないので、初期化できません！
% All that the class can do is to send \ind{initialization} messages, possibly using accessors, to newly created instances.
クラスができることは、新しく生成されたインスタンスに、\ind{初期化}メッセージを送信することと、可能ならばアクセサを使うことです。

% Similarly, instances can only access class instance variables indirectly, by sending accessor messages to their class.
同じようにインスタンスからクラスインスタンス変数にアクセスするには、クラスにアクセサメッセージを送ることによって間接的にアクセスするしかありません。

% \ind{Java} has nothing equivalent to class instance variables.  
\ind{Java}にはクラスインスタンス変数に相当するものはありません。
% Java and \ind{C++} static variables are more like \st class variables, which we will discuss in \secref{classVars}: all of the subclasses and all of their instances share the same static variable.
Javaと\ind{C++}の静的変数は、\stではどちらかというと\secref{classVars}で説明するクラス変数に似ています：全てのサブクラスやインスタンスは同一の静的変数を共有します。

% \paragraph{Example: Defining a Singleton.}
\paragraph{例題: シングルトンを定義する。}
% The \ind{Singleton pattern}~\cite{Alpe98a} provides a typical example of the use of class instance variables and class methods.
\ind{シングルトンパターン}~\cite{Alpe98a}はクラスインスタンス変数とクラスメソッドを使う典型例です。
% Imagine that we would like to implement a class \ct{WebServer} and use the Singleton pattern to ensure that it has only one instance.
\ct{WebServer}クラスを実装してみましょう。シングルトンパターンを使って、\ct{WebServer}クラスには1つしかインスタンスがないことを保証します。

% Clicking on the \button{instance} button in the browser, we define the class \clsind{WebServer} as follows (\clsref{singleton}).
ブラウザの\button{instance}ボタンをクリックして、\clsind{WebServer}クラスを以下のように定義します。(\clsref{singleton})

\begin{classdef}[singleton]{シングルトンクラス}
Object subclass: #WebServer
	instanceVariableNames: 'sessions' 	
	classVariableNames: '' 	
	poolDictionaries: '' 	
	category: 'Web'
\end{classdef}

% Then, clicking on the \button{class} button, we add the instance variable \ct{uniqueInstance} to the \subind{browser}{class side}.
そして、\button{class}ボタンをクリックして、\subind{ブラウザ}{クラス側}でインスタンス変数\ct{uniqueInstance}を追加します。

% \begin{classdef}[webserver]{The class side of the singleton class}
\begin{classdef}[webserver]{シングルトンクラスのクラス側}
WebServer class 	
	instanceVariableNames: 'uniqueInstance'
\end{classdef}

% The consequence of this is that the class \ct{WebServer} now has another instance variable,
この結果、\ct{WebServer}クラスにはもう1つのインスタンス変数が追加されます。
% in addition to the variables that it inherits, such as \ct{superclass} and \ct{methodDict}.
それまでは、\ct{superclass}や\ct{methodDict}といった変数を継承していました。

% We can now define a class \subind{class}{method} named \ct{uniqueInstance} as shown in \mthref{uniqueInstance}. 
さて、これで\subind{クラス}{メソッド}\ct{luniqueInstance}を定義することができます。\mthref{uniqueInstance}に示します。
% This method first checks whether \ct{uniqueInstance} has been initialized.
このメソッドはまず、\ct{uniqueInstance}が初期化されているかどうかをチェックします。
% If it has not, the method creates an instance and assigns it to the class instance variable \ct{uniqueInstance}.
もしまだならば、インスタンスを生成して、クラスインスタンス変数\ct{uniqueInstance}に代入します。
% Finally the value of \ct{uniqueInstance} is returned.
最後に、\ct{uniqueInstance}の値が返されます。
% Since \ct{uniqueInstance} is a class instance variable, this method can directly access it.
\ct{uniqueInstance}はクラスインスタンス変数なので、このメソッドは直接アクセスすることができます。
    
% \begin{method}[uniqueInstance]{uniqueInstance (on the class side)}
\begin{method}[uniqueInstance]{uniqueInstance (クラス側)}
WebServer class>>>uniqueInstance
     uniqueInstance ifNil: [uniqueInstance := self new].
     ^ uniqueInstance
\end{method}

% The first time that \ct{WebServer uniqueInstance} is executed, an instance of the class \ct{WebServer} will be created and assigned to the \ct{uniqueInstance} variable. 
\ct{Webserver uniqueInstance}が最初に実行される時には、\ct{WebServer}クラスのインスタンスが生成され、変数\ct{uniqueInstance}に代入されます。
% The next time, the previously created instance will be returned instead of creating a new one. 
次回の実行では、新しいインスタンスを生成することなしに、前回生成されたインスタンスが返されます。

% Note that the instance creation code inside the conditional in \mthref{uniqueInstance} is written as \ct{self new} and not as \ct{WebServer new}.
\mthref{uniqueInstance}の条件分岐の内側にあるインスタンス生成のコードが\ct{self new}という形であって、\ct{WebServer new}ではないことに留意してください。
% What is the difference?   Since the \ct{uniqueInstance} method is defined in \ct{WebServer class}, you might think that they were the same.    And indeed, until someone creates a subclass of \lct{WebServer}, they are the same.  But suppose that \ct{ReliableWebServer} is a subclass of \ct{WebServer}, and inherits the \ct{uniqueInstance} method.  We would clearly expect \ct{ReliableWebServer uniqueInstance} to answer a \lct{ReliableWebServer}:. Using \self ensures that this will happen, since it will be bound to the respective class.
何が違うのでしょうか？
\ct{uniqueInstance}メソッドは\ct{WebServer class}に定義されているので、同じことだと思うかもしれません。
\ct{WebServer}のサブクラスが作られるまでは本当に同じなのですが、\ct{ReliableWebServer}が\lct{WebServer}のサブクラスで、\ct{uniqueInstance}メソッドを継承していたりしたらどうでしょうか。
\ct{ReliableWebServer uniqueInstance}の結果は\lct{ReliableWebServer}であることを期待するでしょう。
\selfを使うことで、そうなることが保証されます。\selfはメッセージを受けたクラスなので。

% Note also that \ct{WebServer} and \ct{ReliableWebServer} will each have their own class instance variable called \ct{uniqueInstance}.  These two variables will of course have different values.
\ct{WebServer}と{ReliableWebServer}はそれぞれ自分のクラスインスタンス変数\ct{uniqueInstance}を持っていることにも留意してください。それぞれの変数は、もちろん、別々の値を持ちます。

%=========================================================
% \section{Every class has a superclass}
\section{全てのクラスはスーパークラスを持っている}

%\ruleref{inheritance}

% Each class in \st inherits its behaviour and the description of its structure from a single \emphind{superclass}.
\stでは、それぞれのクラスは単一の\emphind{スーパークラス}から振舞いと構造の記述を継承します。
% This means that \st has single \ind{inheritance}.
つまり\stは単一\ind{継承}を持っています。

\needlines{2}
\begin{code}{@TEST}
SmallInteger superclass --> Integer
Integer superclass          --> Number
Number superclass        --> Magnitude
Magnitude superclass    --> Object
Object superclass           --> ProtoObject
ProtoObject superclass  --> nil
\end{code}

% Traditionally the root of the \st inheritance hierarchy is the class \clsind{Object} (since everything is an object).
伝統的には、\stの継承階層のルートは\clsind{Object}クラスです。(なぜなら、全てのものはオブジェクトだからです。)
% In \pharo, the root is actually a class called \clsind{ProtoObject}, but you will normally not pay any attention to this class.
\pharoでは、実際にはルートは\clsind{ProtoObject}と呼ばれるクラスです。しかし、通常はこのクラスに注意する必要はありません。
% \ct{ProtoObject} encapsulates the minimal set of messages that all objects \emph{must} have.  However, most classes inherit from \ct{Object}, which defines many additional messages that almost all objects ought to understand and respond to.
\ct{ProtoObject}は全てのオブジェクトが持って\emph{いなければならない}最低限のメッセージをカプセル化しています。
しかしながら、ほとんどのクラスは\ct{Object}から継承していて、\ct{Object}はほとんど全てのオブジェクトが理解し対応するべき沢山のメッセージを追加して定義しています。
% Unless you have a very good reason to do otherwise, when creating application classes you should normally subclass \ct{Object}, or one of its subclasses.
特別な理由がないかぎり、アプリケーションクラスを生成する時には、通常\ct{Object}やそのサブクラスのどれかのサブクラスとするべきです。

% \dothis{A new class is normally created by sending the message
\dothis{新しいクラスを生成するには、既存のクラスに
\ct{subclass: instanceVariableNames: ...}
% to an existing class.
というメッセージを送ります。
% There are a few other methods to create classes.
他にもいくつかクラスを生成するメソッドがあります。
% Have a look at the protocol \prot{Kernel-Classes \go Class \go subclass creation} to see what they are.}
\prot{Kernel-Classes \go Class \go subclass creation}プロトコルを見て、どのようなメソッドがあるか見てみてください。}
\scatindex{Kernel-Classes}
\protindex{creation}

%There is no special syntax for creating abstract classes in \st.
%An abstract class is an ordinary class in which the implementation of some methods is deferred to a subclass.
%This is repeated in the next section

% Although \pharo does not provide multiple inheritance, it supports a mechanism called \emphind{trait}{}s for sharing behaviour across unrelated classes.
\pharoには多重継承はありませんが、互いに関係のないクラスで同じ振る舞いを共有する\emphind{trait}{}と呼ばれるメカニズムをサポートしています。
% Traits are collections of methods that can be reused by multiple classes that are not related by inheritance. Using traits allows one to share code between different classes without duplicating code.
トレイトはメソッドの集合で、継承関係にない複数のクラスの間で再利用されます。
トレイトを使うと、同じをコードを繰り返し定義することなく、別々のクラスの間で共有させることができます。

%---------------------------------------------------------
% \subsection{Abstract methods and abstract classes}
\subsection{抽象メソッドと抽象クラス}

% An \subind{class}{abstract} class is a class that exists to be subclassed, rather than to be instantiated.
\subind{クラス}{抽象}クラスは、インスタンスを生成するのではなく、サブクラスを生成するために存在するクラスです。
% An abstract class is usually incomplete, in the sense that it does not define all of the methods that it uses.
抽象クラスは通常は不完全で、必要なメソッドの全てが実装されてはいません。
% The ``missing'' methods\,---\,those that the other methods assume, but which are not themselves defined\,---\,are called \subind{method}{abstract} methods.
``ない''メソッド---他のメソッドがそのメソッドがあることを想定しているのに定義されていないメソッド---を\subind{メソッド}{抽象}メソッドと呼びます。
\seeindex{抽象クラス}{クラス, 抽象}
\seeindex{抽象メソッド}{メソッド, 抽象}

% \st has no dedicated syntax to specify that a method or a class is abstract. 
\stには、抽象メソッドや抽象クラスであることを指定する特別な構文はありません。
% By convention, the body of an abstract method consists of the expression \mbox{\ct{self subclassResponsibility}.} 
コード規約として、抽象メソッドの本文は\mbox{\ct{self subclassResponsibility}}と書きます。
% This is known as a ``marker method'', and indicates that subclasses have the responsibility to define a concrete version of the method. 
これはいわゆる``マーカーメソッド''といって、サブクラスにそのメソッドの具体的な定義を定義する責任があることを示しています。
% \ct{self subclassResponsibility} methods should always be overridden, and thus should never be executed.
\ct{self subclassResponsibility}メソッドは必ずオーバーライドされなければならず、したがって、絶対に実行してはならないというものです。
% If you forget to override one, and it is executed, an exception will be raised. 
もしオーバーライドし忘れたら、そのメソッドが実行され、例外が発生してしまいます。
\cmindex{Object}{subclassResponsibility}

% A class is considered abstract if one of its methods is abstract.
抽象メソッドを持つクラスが抽象クラスです。
% Nothing actually prevents you from creating an instance of an abstract class; everything will work until an abstract method is invoked. 
実際には抽象クラスのインスタンスを生成しないようにする仕組みはありません。抽象メソッドが実行されるまでは、普通に動作します。

% \subsubsection{Example: the class \ct{Magnitude}.}
\subsubsection{例題: \ct{Magnitude}クラス}
%\clsind{Magnitude} is an abstract class that helps us to  define objects that can be compared to each other. Subclasses of \ct{Magnitude} should implement the methods \ct{<}, \ct{=} and \ct{hash}. Using such messages \ct{Magnitude} defines other methods such as \ct{>}, \ct{>=}, \ct{<=}, \ct{max:}, \ct{min:} \ct{between:and:} and others for comparing objects. Such methods are inherited by subclasses. The method \mthind{Magnitude}{<} is abstract and defined as shown in \mthref{MagnitudeLessThan}.
\clsind{Magnitude}は互いに比較するクラスを定義するのに役立つ抽象クラスです。
\ct{Magnitude}のサブクラスは\ct{<}および\ct{=}、\ct{hash}の3つのメソッドを定義しなければなりません。
\ct{Magnitude}では、それらのメッセージを使って\ct{>}および\ct{>=}、\ct{<=}、\ct{max:}、\ct{min:}、\ct{between:and:}等のメソッドを定義しています。
\mthind{Magnitude}{<}は抽象メソッドで、\mthref{MagnitudeLessThan}に示すように定義されています。

\begin{method}[MagnitudeLessThan]{\ct{Magnitude>>><}}
Magnitude>>>< aMagnitude 
	"Answer whether the receiver is less than the argument."
	^self subclassResponsibility
\end{method}

\noindent
% By contrast, the method \mthind{Magnitude}{>=} is concrete; it is defined in terms of \ct{<}:
対照的に、\mthind{Magnitude}{>=}は具象メソッドで、\ct{<}を使って定義されています。

\begin{method}[Magnitude>=]{\ct{Magnitude>>>>=}}
>= aMagnitude 
	"Answer whether the receiver is greater than or equal to the argument."
	^(self < aMagnitude) not
\end{method}
% The same is true of the other comparison methods.
他の比較メソッドも同様です。

% \clsind{Character} is a subclass of \ct{Magnitude}; it overrides the \mthind{Object}{subclassResponsibility} method for \ct{<} with its own version of \ct{<} (see \mthref{CharacterLessThan}).  \ct{Character} also defines methods \ct{=} and \ct{hash}; it inherits from \ct{Magnitude} the methods \ct{>=}, \ct{<=}, \ct{~=} and others.
\clsind{Character}は\ct{Magnitude}のサブクラスで、\ct{<}メソッドの\mthind{Object}{subclassResponsibility}をオーバーライドして独自のメソッドを定義しています(\mthref{CharacterLessThan}参照)。\ct{Character}は\ct{=}メソッドおよび\ct{hash}メソッドも定義していて、\ct{>=}および\ct{<=}、\ct{~=}等のメソッドを\ct{Magnitude}から継承しています。

\begin{method}[CharacterLessThan]{\ct{Character>>><}}
Character>>>< aCharacter 
	"Answer true if the receiver's value < aCharacter's value."
	^self asciiValue < aCharacter asciiValue
\end{method}

%---------------------------------------------------------
% \subsection{Traits}
\subsection{トレイト}
% A \emphind{trait} is a collection of methods that can be included in the behaviour of a class without the need for inheritance.
\emphind{トレイト}は、継承なしにクラスの振る舞いに取り込むことができるメソッドの集合です。
% This makes it easy for classes to have a unique superclass, yet still share useful methods with otherwise unrelated classes.
これによって、単一継承の容易さを保ちながら、別々のクラスに有用なメソッドを共通化することができます。

% To define a new trait, simply replace the subclass creation template by a message to the class \clsind{Trait}.
新しいトレイトを定義する方法は、単にサブクラス定義のテンプレートの代わりに、\clsind{Trait}クラスへのメッセージに置き換えるだけです。

\needspace{5\baselineskip}
% \begin{classdef}[tauthor]{Defining a new trait}
\begin{classdef}[tauthor]{新しいトレイトを定義する}
Trait named: #TAuthor
	uses: { }
	category: 'PBE-LightsOut'
\end{classdef}

\noindent
% Here we define the trait \ct{TAuthor} in the category \scat{PBE-LightsOut}.
ここでは、\scat{PBE-LightsOut}カテゴリに\ct{TAuthor}トレイトを定義しています。
% This trait does not \emph{use} any other existing traits.
このトレイトは既存のトレイトは\emph{使って}いません。
% In general we can specify a \emph{trait composition expression} of other traits to use as part of the \ct{uses:} keyword argument.
一般には、\ct{uses:}キーワードの引数の一部に、他のトレイトの\emph{トレイト合成式}を使うことができます。
% Here we simply provide an empty array.
ここでは単に空の配列を与えています。

% Traits may contain methods, but no instance variables.
トレイトはメソッドは持つことができますが、インスタンス変数は持ちません。
% Suppose we would like to be able to add an \ct{author} method to various classes, independent of where they occur in the hierarchy.
% We might do this as follows:
以下のようにすると、色々なクラスに、階層のどこに位置するかに関係なく\ct{author}メソッドを追加できるようになります。

% \begin{method}[author]{An author method}
\begin{method}[author]{authorメソッド}
TAuthor>>>authorj
    "著者の頭文字を返す"
	^ 'on'    "oscar nierstraszの頭文字"
\end{method}

\noindent
% Now we can use this trait in a class that already has its own superclass, for instance the \ct{LOGame} class that we defined in \charef{firstApp}.
さあ、これで既にスーパークラスを持っているクラスに対してこのトレイトを使うことができます。例えば、\charef{firstApp}で定義した\ct{LOGame}クラスです。
% We simply modify the class creation template for \ct{LOGame} to include a \ct{uses:} keyword argument that specifies that \ct{TAuthor} should be used.
単に、\ct{LOGame}クラスを生成するテンプレートを書き変えて、\ct{uses:}キーワードの引数で\ct{TAuthor}を使うように指定するだけです。

% \begin{classdef}[sbegamewithtrait]{Using a trait}
\begin{classdef}[sbegamewithtrait]{トレイトを使う}
BorderedMorph subclass: #LOGame
	uses: TAuthor
	instanceVariableNames: -'cells'ss
	classVariableNames: ''e
	poolDictionaries: ''
	category: 'PBE-LightsOut'
\end{classdef}

% If we now instantiate \ct{LOGame}, it will respond to the \ct{author} message as expected.
これで、\ct{LOGame}のインスタンスを生成したら、そのインスタンスは期待通り\ct{author}メッセージに答えてくれるでしょう。

\begin{code}{}
LOGame new author --> 'on'
\end{code}

% Trait composition expressions may combine multiple traits using the \ct{+} operator.
トレイト合成式では複数のトレイトを\ct{+}演算子でつなげることができます。
% In case of conflicts (\ie if multiple traits define methods with the same name), these conflicts can be resolved by explicitly removing these methods (with \ct{-}), or by redefining these methods in the class or trait that you are defining.
もし不整合(例えば、複数のトレイトが同じ名前のメソッドを定義したら)があれば、\ct{-}演算子でそれらのメソッドを明示的に除外したり、あるいは、今定義しているクラスやトレイトで再定義することで、不整合を解消することができます。
% It is also possible to \emph{alias} methods (with \ct{@}), providing a new name for them.
\ct{@}演算子でメソッドに\emph{エイリアス}として新しい名前を与えることも可能です。

% Traits are used in the system kernel.
トレイトはシステムの中核部分で使われています。
% One good example is the class \mbox{\clsind{Behavior}.}
\mbox{\clsind{Behavior}}クラスが良い例です。

\needlines{8}
% \begin{classdef}[behaviorwithtraits]{\ct{Behavior} defined using traits}
\begin{classdef}[behaviorwithtraits]{\ct{Behavior}の定義で使われているトレイト}
Object subclass: #Behavior
	uses: TPureBehavior @ {#basicAddTraitSelector:withMethod:->#addTraitSelector:withMethod:}
	instanceVariableNames: 'superclass methodDict format'
	classVariableNames: 'ObsoleteSubclasses'
	poolDictionaries: ''
	category: 'Kernel-Classes'
\end{classdef}
\noindent
% Here we see that the method \ct{addTraitSelector:withMethod:} defined in the trait \ct{TPureBehavior} has been aliased to \ct{basicAddTraitSelector:withMethod:}.
ここでは、\ct{TPureBehavior}で定義されている\ct{addTraitSelector:withMethod:}メソッドが\ct{basicAddTraitSelector:withMethod:}にエイリアスされています。
% Support for traits is currently being added to the browsers.
現在、ブラウザにトレイトへのサポートが追加されているところです。

%=========================================================
%\section{Everything happens by sending messages}
\section{あらゆるコトは、メッセージ送信で起こる}

%\ruleref{message}

% This rule captures the essence of programming in \st.
この規則は、\stプログラミングの本質を捉えています。

% In procedural programming, the choice of which piece of code to execute when a procedure is called is made by the caller.
手続き的プログラミングでは、手続きが呼ばれた時にどのコードが使われるかは、呼び出し側が決めます。
% The caller chooses the procedure or function to execute \emph{statically}, by name.  
呼び出し側が、名前で、\emph{静的に}、手続きや関数を選んで実行します。

% In object-oriented programming, we do \emph{not} ``call methods'': we ``\subind{message}{send} messages.''
オブジェクト指向プログラミングでは、``メソッドを呼び出し''\emph{ません}。``メッセージを\subind{メッセージ}{送信}''ます。
% The choice of terminology is significant.
この用語の違いは重要です。
% Each object has its own responsibilities.
それぞれのオブジェクトにはそれぞれの責任があります。
% We do not \emph{tell} an object what to do by applying some procedure to it.
オブジェクトを手続きに渡すことで、そのオブジェクトが何をすべきか\emph{指示する}ようなことはしません。
% Instead, we politely \emph{ask} an object to do something for us by sending it a message.
そうではなく、オブジェクトにメッセージを送ることで、オブジェクトに何かをするように\emph{お願い}するのです。
% The message is \emph{not} a piece of code: it is nothing but a name and a list of arguments.
ここで、メッセージはコードでは\emph{ありません}。まさに名前と引数のリストだけです。
% The receiver then decides how to respond by selecting its own \emph{method} for doing what was asked.
メッセージを受けたレシーバは、そこで、頼まれたことを実行するための\emph{メソッド}を選択して、どう対応するのかを決めます。
% Since different objects may have different methods for responding to the same message, the method must be chosen \emph{dynamically}, when the message is received.
同じメッセージに対してオブジェクトによって別々のメソッドを持っていることがあるので、メソッドはメッセージを受け取った時に\emph{動的に}選択されなければなりません。
\begin{code}{@TEST}
% 3 + 4         --> 7          "send message + with argument 4 to integer  3"
3 + 4         --> 7          "整数「3」にメッセージ「+」と引数「4」を送信する"
% (1@2) + 4 --> 5@6    "send message + with argument 4 to point (1@2)"
(1@2) + 4 --> 5@6    "点「(1@2)」にメッセージ「+」と引数「4」を送信する"
\end{code}
\noindent
% As a consequence, we can send the \emph{same message} to different objects, each of which may have \emph{its own method} for responding to the message.
したがって、\emph{同じメッセージ}を異なるオブジェクトに送信することができ、それぞれのオブジェクトはそのメッセージに対応するために\emph{オブジェクト毎のメソッド}を持つことができます。
% We do not tell the \ct{SmallInteger} \ct{3} or the \ct{Point} \ct{1@2} how to respond to the message \ct{+ 4}.
\ct{+ 4}というメッセージにどう対応するのかを\ct{SmallInteger} \ct{3}や\ct{Point} \ct{1@2}に指示しないのです。
% Each has its own method for \ct{+}, and responds to \ct{+ 4} accordingly.
それぞれが\ct{+}メソッドを持っていて、そのメソッドに従って\ct{+ 4}に対応するのです。

% One of the consequences of \st's model of message sending is that it encourages a style in which objects tend to have very small methods and delegate tasks to other objects, rather than implementing huge, procedural methods that assume too much responsibility.
\stのメッセージ送信のモデルの帰結として言えることがあります。オブジェクトはとても小さなメソッドを持ち他のオブジェクトに仕事を移譲し、巨大で手続き的なメソッドで過大な責任をかかえることを避ける傾向を持つということです。
% Joseph Pelrine
ジョセフ・ペルリン(Joseph Pelrine)はこの原則を次のように簡潔に表現しています。
\ab{Citation?}
\on{sorry, just personal communication and my own lecture notes!}
% expresses this principle succinctly as follows:
% \important{Don't do anything that you can push off onto someone else.}
\important{誰かに押しつけられる仕事を自分でやらないこと。}
\index{Pelrine, Joseph}

% Many object-oriented languages provide both static and dynamic operations for objects; in \st there are only dynamic message sends. Instead of providing static class operations, for instance, classes are objects and we simply send messages to classes.
多くのオブジェクト指向言語はオブジェクトに対して静的動的両方の操作方法を提供していますが、\stでは動的なメッセージ送信だけです。
静的な操作の代わりに、例えば、クラスがオブジェクトであることで、単にクラスにメッセージを送ります。

% \emph{Nearly} everything in \st happens by sending messages.
\stでは、\emph{ほぼ}全てのコトはメッセージ送信で起こります。
% At some point action must take place:
いずれかの時点で、メッセージ送信ではない処理が必ず発生します。
\begin{itemize}
%  \item \emph{Variable declarations} are not message sends.
  \item \emph{変数宣言}はメッセージ送信ではありません。
%  		In fact, variable \subind{variable}{declaration}{}s are not even executable.
		実際、変数\subind{変数}{宣言}{}は実行可能ですらありません。
%  		Declaring a variable just causes space to be allocated for an object reference.
		変数宣言はオブジェクトへの参照を格納する領域を確保する意味しかありません。
%  \item \emph{Assignments} are not message sends.
  \item \emph{代入}はメッセージ送信ではありません。
%  		An \ind{assignment} to a variable causes that variable name to be freshly bound in the scope of its definition.
		変数への\ind{代入}はその定義スコープ内で名前を束縛します。
%  \item \emph{Returns} are not message sends.
  \item \emph{リターン}はメッセージ送信ではありません。
%  		A \ind{return} simply causes the computed result to be returned to the sender.
		\ind{リターン}は計算結果をメッセージの送り手に返します。
%  \item \emph{Primitives} are not message sends.
  \item \emph{プリミティブ}はメッセージ送信ではありません。
%  		They are implemented in the \ind{virtual machine}.
		プリミティブは\ind{仮想マシン}に実装されています。
		\index{プリミティブ}
\end{itemize}
% Other than these few exceptions, pretty much everything else does truly happen by sending messages.
これら僅かな例外を除いて、他の色々なコトはメッセージ送信で起こるのです。
% In particular, since there are no ``public fields'' in \st, the only way to update an \ind{instance variable} of another object is to send it a message asking that it update its own field.
特に、\stには``パブリックなフィールド''はないので、他のオブジェクトの\ind{インスタンス変数}を更新するには、メッセージを送ってそのオブジェクト自身のフィールドを更新するようにお願いするしかありません。
% Of course, providing setter and getter methods for all the instance variables of an object is not good object-oriented style.
もちろん、全てのインスタンス変数についてセッターメソッドやゲッターメソッドを定義するのは、オブジェクト指向として良いスタイルとは言えません。
% Joseph Pelrine also states this very nicely:
ジョセフ・ペルリンは次のようにも言っています。
% \important{Don't let anyone else play with your data.}
\important{あなたが持っているデータを他人に弄らせるな。}

%=========================================================
\section{Method lookup follows the inheritance chain} 

%\ruleref{lookup}

What exactly happens when an object receives a message?

The process is quite simple:
the class of the receiver looks up the method to use to handle the message.
If this class does not have a method, it asks its \ind{superclass}, and so on, up the \ind{inheritance} chain.
When the method is found, the arguments are bound to the parameters of the method, and the \ind{virtual machine} executes it.
\index{method!lookup}

It is essentially as simple as this.
Nevertheless there are a few questions that need some care to answer:

\begin{itemize}
  \item \emph{What happens when a method does not explicitly return a value?}
  \item \emph{What happens when a class reimplements a superclass method?}
  \item \emph{What is the difference between \pvind{self} and \pvind{super} sends?}
  \item \emph{What happens when no method is found?}
\end{itemize}

The rules for method lookup that we present here are conceptual: virtual machine implementors use all kinds of tricks and optimizations to speed-up method lookup. 
That's their job, but you should never be able to detect that they are doing something different from our rules.
% Whatever the implementation does, these rules will give you a clear understanding of the semantics of sending messages to \self and \super.

First let us look at the basic lookup strategy, and then consider these further questions.

%---------------------------------------------------------
\subsection{Method lookup}
Suppose we create an instance of \ct{EllipseMorph}.
\begin{code}{@TEST | anEllipse |}
anEllipse := EllipseMorph new.
\end{code}
\noindent
If we now send this object the message \ct{defaultColor}, we get the result \ct{Color yellow}:
\begin{code}{@TEST | anEllipse | anEllipse := EllipseMorph new.}
anEllipse defaultColor --> Color yellow
\end{code}
\noindent
The class \ct{EllipseMorph} implements \ct{defaultColor}, so the appropriate method is found immediately.

\begin{method}[defaultColor]{A locally implemented method}
EllipseMorph>>>defaultColor
	"answer the default color/fill style for the receiver"
	^ Color yellow
\end{method}
\cmindex{EllipseMorph}{defaultColor}

In contrast, if we send the message \ct{openInWorld} to \ct{anEllipse}, the method is not immediately found, since the class \ct{EllipseMorph} does not implement \ct{openInWorld}.
The search therefore continues in the superclass, \lct{BorderedMorph}, and so on, until an \ct{openInWorld} method is found in the class \ct{Morph} (see \figref{openInWorldLookup}).

\begin{method}[openInWorld]{An inherited method}
Morph>>>openInWorld
	"Add this morph to the world."

	self openInWorld: self currentWorld
\end{method}
\cmindex{Morph}{openInWorld}

\begin{figure}[htb]
\begin{center}
	{\includegraphics[width=0.8\textwidth]{openInWorldLookup}}
\caption{Method lookup follows the inheritance hierarchy.\figlabel{openInWorldLookup}}
\end{center}
\end{figure}

%---------------------------------------------------------
\subsection{Returning self}

Notice that \ct{EllipseMorph>>>defaultColor} (\mthref{defaultColor}) explicitly returns \ct{Color yellow} whereas \ct{Morph>>>openInWorld} (\mthref{openInWorld}) does not appear to return anything.

Actually a method \emph{always} answers a message with a value\,---\,which is, of course, an object.
The answer may be defined by the \ct{^} construct in the method, but if execution reaches the end of the method without executing a \ct{^}, the method still answers a value: it answers the object that received the message.
We usually say that the method ``answers \self'', because in Smalltalk the pseudo-variable \self represents the receiver of the message, rather like \ct{this} in \ind{Java}.
\index{variable!pseudo}
\index{return}
\seeindex{caret}{return}

This suggests that \mthref{openInWorld} is equivalent to \mthref{openInWorldReturnSelf}:

\needlines{5}
\begin{method}[openInWorldReturnSelf]{Explicitly returning self}
Morph>>>openInWorld
	"Add this morph to the world."
	
    self openInWorld: self currentWorld
	^ self		"Don't do this unless you mean it!"
\end{method}

Why is writing \ct{^ self} explicitly not a good thing to do?
Well, when you return something explicitly, you are communicating that you are returning something of interest to the sender.
When you explicitly return \self, you are saying that you expect the sender to use the returned value.
This is not the case here, so it is best not to explicitly return \self.

This is a common idiom in \st, which Kent Beck refers to as ``Interesting return value'' \cite{Beck97a}:
\index{Beck, Kent}

\important{Return a value only when you intend for the sender to use the value.}

%---------------------------------------------------------
\subsection{Overriding and extension}

If we look again at the \ct{EllipseMorph} class hierarchy in \figref{openInWorldLookup}, we see that the classes \ct{Morph} and \mbox{\ct{EllipseMorph}} both implement \ct{defaultColor}.
In fact, if we open a new morph (\ct{Morph new openInWorld}) we see that we get a blue morph, whereas an ellipse will be yellow by default.
\index{method!overriding}
\index{method!extension}
\seeindex{overriding}{method, overriding}
\seeindex{extension}{method, extension}

We say that \ct{EllipseMorph} \emph{overrides} the \ct{defaultColor} method that it inherits from \ct{Morph}.
The inherited method no longer exists from the point of view of \ct{anEllipse}.

Sometimes we do not want to override inherited methods, but rather \emph{extend} them with some new functionality, that is, we would like to be able to invoke the overridden method \emph{in addition to} the new functionality we are defining in the subclass.
In \st, as in many object-oriented languages that support single inheritance, this can be done with the help of \super sends.

The most important application of this mechanism is in the \ct{initialize} method.
Whenever a new instance of a class is initialized, it is critical to also initialize any inherited instance variables.
However, the knowledge of how to do this is already captured in the \ct{initialize} methods of each of the superclass in the inheritance chain.
The subclass has no business even trying to initialize inherited instance variables!

It is therefore good practice whenever implementing an initialize method to send \ct{super initialize} before performing any further \ind{initialization}:
\index{super!initialize}

\needlines{6}
\begin{method}[morphinit]{Super initialize}
BorderedMorph>>>initialize
	"initialize the state of the receiver"
	super initialize.
	self borderInitialize
\end{method}

\important{An \ct{initialize} method should always start by sending \ct{super initialize}.}

%---------------------------------------------------------
\subsection{Self sends and super sends}

We need \super \subind{super}{send}{}s to compose inherited behaviour that would otherwise be overridden.
The usual way to compose methods, whether inherited or not, however, is by means of \self \subind{self}{send}{}s.

How do \self sends differ from \super sends?
Like \self, \super represents the receiver of the message.
The only thing that changes is the \ind{method lookup}.
Instead of lookup starting in the class of the receiver, it starts in the superclass of the class of the method where the \super send occurs.

Note that \super is \emph{not} the superclass!
It is a common and natural mistake to think this.
It is also a mistake to think that lookup starts in the superclass of the receiver.
We shall see with the following example precisely how this works.

Consider the message \ct{constructorString}, which we can send to any morph:
\begin{code}{@TEST | anEllipse | anEllipse := EllipseMorph new.}
anEllipse constructorString --> '(EllipseMorph newBounds: (0@0 corner: 50@40) color: Color yellow)'
\end{code}
The return value is a string that can be evaluated to recreate the morph.

How exactly is this result obtained through a combination of \self and \super sends?
First, \ct{anEllipse constructorString} will cause the method \ct{constructorString} to be found in the class \ct{Morph},
as shown in \figref{constructorStringLookup}.

\begin{figure}[htb]
\begin{center}
\ifluluelse
	{\includegraphics[width=\textwidth]{constructorStringLookup}}
	{\includegraphics[width=0.8\textwidth]{constructorStringLookup}}
\caption{\self and \super sends\figlabel{constructorStringLookup}}
\end{center}
\end{figure}

\needlines{2}
\begin{method}[constructorString]{A \self send}
Morph>>>constructorString
	^ String streamContents: [:s | self printConstructorOn: s indent: 0].
\end{method}
The method \cmind{Morph}{constructorString} performs a \self send of \lct{printConstructorOn:indent:}.
This message is also looked up, starting in the class \lct{EllipseMorph}, and found in \ct{Morph}.
This method in turn does a \self send of \lct{printConstructorOn:indent:nodeDict:}, which does a \self send of \ct{fullPrintOn:}.
Once again, \ct{fullPrintOn:} is looked up starting in the class \ct{EllipseMorph}, and \mthind{BorderedMorph}{fullPrintOn:} is found in \ct{BorderedMorph} (see \figref{constructorStringLookup} once again).
What is critical to notice is that the \self send causes the method lookup to start again in the class of the receiver, namely the class of \ct{anEllipse}.

\important{A \self send triggers a \emph{dynamic} method lookup starting in the class of the receiver.}

\needlines{4}
\begin{method}[fullPrintOn]{Combining \super and \self sends}
BorderedMorph>>>fullPrintOn: aStream
	aStream nextPutAll: '('.
	!\textbf{super fullPrintOn: aStream.}!
	aStream nextPutAll: ') setBorderWidth: '; print: borderWidth;
		nextPutAll: ' borderColor: ' , (self colorString: borderColor)
\end{method}
At this point, \ct{BorderedMorph>>>fullPrintOn:} does a \super send to extend the 
\ct{fullPrintOn:} behaviour it inherits from its superclass.
Because this is a \super send, the lookup now starts in the superclass of the class where the \super send occurs, namely in \ct{Morph}.
We then immediately find and evaluate \ct{Morph>>>fullPrintOn:}.

Note that the \super lookup did not start in the superclass of the receiver.
This would have caused lookup to start from \ct{BorderedMorph}, resulting in an infinite loop!

\important{A \super send triggers a \emph{static} method lookup starting in the superclass of the class of the method performing the \super send.}

If you think carefully about \super send and \figref{constructorStringLookup}, you will realize that \super bindings are static: all that matters is the class in which the text of the \super send is found.
By contrast, the meaning of \self is dynamic: it always represents the receiver of the currently executing message. This means that  \emph{all}  messages sent to \self are looked-up by starting in the receiver's class.

%---------------------------------------------------------
\subsection{Message not understood}

What happens if the method we are looking for is not found?
\index{message!not understood}

Suppose we send the message \ct{foo} to our ellipse.
First the normal method lookup would go through the inheritance chain all the way up to \clsind{Object} (or rather \clsind{ProtoObject}) looking for this method.
When this method is not found, the \ind{virtual machine} will cause the object to send \ct{self doesNotUnderstand: #foo}.
(See \figref{fooNotFound}.)

\begin{figure}[htb]
\begin{center}
\ifluluelse
	{\includegraphics[width=\textwidth]{fooNotFound}}
	{\includegraphics[width=0.8\textwidth]{fooNotFound}}
\caption{Message \lct{foo} is not understood\figlabel{fooNotFound}}
\end{center}
\end{figure}

Now, this is a perfectly ordinary, dynamic message send, so the lookup starts again from the class \ct{EllipseMorph}, but this time searching for the method \ct{doesNotUnderstand:}.
As it turns out, \ct{Object} implements \ct{doesNotUnderstand:}.
This method will create a new \ct{MessageNotUnderstood} object which is capable of starting a Debugger in the current execution context.

Why do we take this convoluted path to handle such an obvious error?
Well, this offers developers an easy way to intercept such errors and take alternative action.
One could easily override the method \mthind{Object}{doesNotUnderstand:} in any subclass of \ct{Object} and  provide a different way of handling the error.

In fact, this can be an easy way to implement automatic delegation of messages from one object to another.
A \ct{Delegator} object could simply delegate all messages it does not understand to another object whose responsibility it is to handle them, or raise an error itself!

%=========================================================
\section{Shared variables}

Now we will look at an aspect of \st that is not so easily covered by our five rules: \subind{variable}{shared} variables.

\st provides three kinds of shared variables: (1) \emph{globally} shared variables; (2) variables shared between instances and classes (\emph{class variables}), and (3) variables shared amongst a group of  classes (\emph{pool variables}).  The names of all of these shared variables start with a capital letter, to warn us that they are indeed shared between multiple objects.
\index{variable!global}
\index{class!variable}
\index{variable!pool}

%---------------------------------------------------------
\subsection{Global variables}
In \pharo, all global variables are stored in a namespace called \glbind{Smalltalk}, which is implemented as an instance of the class \clsind{SystemDictionary}.
Global variables are accessible everywhere. 
Every class is named by a global variable; in addition, a few globals are used to name special or commonly useful objects.

The variable \glbind{Transcript} names an instance of \clsind{TranscriptStream}, a stream that writes to a scrolling window.
The following code displays some information and then goes to the next line in the \ct{Transcript}.

\begin{code}{}
Transcript show: 'Pharo is fun and powerful' ; cr
\end{code}

\noindent
Before you \menu{do it}, open a transcript by selecting \menu{World \go Tools \ldots \go Transcript}.

\hint{Writing to the Transcript is slow, especially when the transcript window is open. 
So, if you experience some sluggishness and are writing to the Transcript, think about collapsing it.}

\subsubsection{Other useful global variables}

\begin{itemize}
\item
\ct{Smalltalk} is the instance of \ct{SystemDictionary} that defines all of the globals\,---\,including \ct{Smalltalk} itself.   
The keys to this dictionary are the symbols that name the global objects in \st code.
So, for example,
\begin{code}{@TEST}
Smalltalk at: #Boolean --> Boolean
\end{code}
Since \ct{Smalltalk} is itself a global variable,
\begin{code}{}
Smalltalk at: #Smalltalk-->a SystemDictionary(lots of globals)}
\end{code} 
and
\begin{code}{@TEST}
(Smalltalk at: #Smalltalk) == Smalltalk --> true
\end{code}

\item \clsind{Sensor} is an instance of \clsind{EventSensor}, and represents input to \pharo.
For example, \lct{Sensor keyboard} answers the next character input on the keyboard, and \ct{Sensor leftShiftDown} answers \ct{true} if the left shift key is being held down, while \ct{Sensor mousePoint} answers a \ct{Point} indicating the current mouse location.

\item \glbind{World} is an instance of \clsind{PasteUpMorph} that represents the screen.
\ct{World bounds} answers a rectangle that defines the whole screen space; all Morphs on the screen are submorphs of \ct{World}.
\index{Morphic}

\item 
\glbind{ActiveHand} is the current instance of \clsind{HandMorph}, the graphical representation of the cursor.  \ct{ActiveHand}'s submorphs hold anything being dragged by the mouse.
\ab{I have never used this, and had to browse the image to see what it is!  What do you use it for?}

\item
\glbind{Undeclared} is another dictionary\,---\,it contains all the undeclared variables.
If you write a method that references an undeclared variable, the browser will normally
prompt you to declare it, for example, as a global or as an instance variable of the class.
However, if you later delete the declaration, the code will then reference an undeclared variable.
Inspecting \ct{Undeclared} can sometimes help explain strange behaviour!

\item
\glbind{SystemOrganization} is an instance of \clsind{SystemOrganizer}: it records the organization of classes into packages.  More precisely, it categorizes the \emph{names} of classes, so
\end{itemize}

\begin{code}{@TEST}
SystemOrganization categoryOfElement: #Magnitude --> #'Kernel-Numbers'
\end{code}

Current practice is to strictly limit the use of global variables; it is usually better to use class instance variables or class variables, and to provide class methods to access them.  Indeed, if \pharo were to be implemented from scratch today, most of the global variables that are not classes would be replaced by singletons.

The usual way to define a global is just to \menu{do it} on an assignment to a capitalized but undeclared identifier.  The parser will then offer to declare the global for you.  If you want to define a global programmatically, just execute \ct{Smalltalk at: #AGlobalName put: nil}.  To remove it, execute \ct{Smalltalk removeKey: #AGlobalName}.
\glbindex{Smalltalk}

%---------------------------------------------------------
\subsection{Class variables}
\seclabel{classVars}

Sometimes we need to share some data amongst all the instances of a 
class and the class itself.
This is possible using \emph{class variables}. 
The term class \subind{class}{variable} indicates that the lifetime of the variable is the same as that of the class. However, what the
term does not convey is that these variables are shared amongst all the instances of a class as well as the class itself,
as shown in \figref{privateSharedVar}.
Indeed, a better name would have been \emph{shared variables} since this expresses more clearly their role, and also warns of the danger of using them, particularly if they are modified.

\begin{figure}[htb]
\begin{center}
\ifluluelse
	{\includegraphics[width=\textwidth]{privateSharedVarColor}}
	{\includegraphics[width=0.7\textwidth]{privateSharedVarColor}}
\caption{Instance and class methods accessing different 
variables.\figlabel{privateSharedVar}}
\end{center}
\end{figure}

In \figref{privateSharedVar} we see that \ct{rgb} and \ct{cachedDepth} are instance variables of \ct{Color}, hence only accessible to instances of \clsind{Color}.
We also see that \lct{superclass}, \lct{subclass}, \lct{methodDict} and so on are class instance variables, \ie instance variables only accessible to the \lct{Color} class.

But we can also see something new: \ct{ColorNames} and \ct{CachedColormaps} are \emph{class variables} defined for \ct{Color}.
The capitalization of these variables gives us a hint that they are shared.
In fact, not only may all instances of \ct{Color} access these shared variables, but also the \ct{Color} class itself, \emph{and any of its subclasses}.
Both instance methods and class methods can access these shared variables.

%\begin{figure}
%\begin{center}\includegraphics[width=6cm]{dateToday}\caption{A date is an object that  represents only anumber of days; all the information about month names, day names, etc.\ is shared among all the instances \figlabel{dateToday}}\end{center}.
%\end{figure}

A class \subind{class}{variable} is declared in the class definition template.
For example, the class \ct{Color} defines a large number of class variables to speed up color creation; its definition is shown below (\clsref{Color}).
\needlines{5}
\begin{classdef}[Color]{Color and its class variables}
Object subclass: #Color 	
        instanceVariableNames: 'rgb cachedDepth cachedBitPattern'
        classVariableNames: 'Black Blue BlueShift Brown CachedColormaps ColorChart ColorNames ComponentMask ComponentMax Cyan DarkGray Gray GrayToIndexMap Green GreenShift HalfComponentMask HighLightBitmaps IndexedColors LightBlue LightBrown LightCyan LightGray LightGreen LightMagenta LightOrange LightRed LightYellow Magenta MaskingMap Orange PaleBlue PaleBuff PaleGreen PaleMagenta PaleOrange PalePeach PaleRed PaleTan PaleYellow PureBlue PureCyan PureGreen PureMagenta PureRed PureYellow RandomStream Red RedShift TranslucentPatterns Transparent VeryDarkGray VeryLightGray VeryPaleRed VeryVeryDarkGray VeryVeryLightGray White Yellow'
        poolDictionaries: '' 	
        category: 'Graphics-Primitives'
\end{classdef}

The class variable \cvind{ColorNames} is an array containing the name of frequently-used colors. This array is shared by all the instances of \ct{Color} and its subclass \clsind{TranslucentColor}. It is accessible from all the instance and class methods. % (see \figref{ClassVarAccess2}).

\ct{ColorNames} is initialized once in \cmind{Color class}{initializeNames}, but it is accessed from instances of \ct{Color}.
The method \cmind{Color}{name} uses the variable to find the name of a color.
Since most colors do not have names, it was thought inappropriate to add an instance variable \ct{name} to every color.

\subsubsection{Class initialization}

The presence of class variables raises the question: how do we initialize them?  
One solution is lazy \subind{class}{initialization}.
This can be done by introducing an accessor method which, when executed, initializes the variable if it has not yet been initialized. This implies that we must use the accessor all the time and never use the class variable directly.  This furthermore imposes the cost of the accessor send and the initialization test.
It also arguably defeats the point of using a class variable, since in fact it is no longer shared.

\begin{method}[colorclasscolornames]{Color class>>colorNames}
Color class>>>colorNames	
	ColorNames ifNil: [self initializeNames].
	^ ColorNames
\end{method}	
\cmindex{Color class}{colorNames}

Another solution is to override the class method \ct{initialize}.

\needlines{3}
\begin{method}[colorclassinit]{Color class>>initialize}
Color class>>>initialize	
	!\ldots!
	self initializeNames
\end{method}	
\cmindex{Color class}{initialize}

\noindent
If you adopt this solution, you need to remember to invoke the \ct{initialize} method after you define it, \eg by evaluating \ct{Color initialize}.
Although \subind{browser}{class side} \ct{initialize} methods are executed automatically when code is loaded into memory, they are \emph{not} executed automatically when they are first typed into the browser and compiled, or when they are edited and re-compiled.

%---------------------------------------------------------
\subsection{Pool variables}
Pool variables are variables that are shared between several classes that may not be related by inheritance.
Pool variables were originally stored in pool dictionaries; now they should be defined as class variables of dedicated classes (subclasses of SharedPool). Our advice is to avoid them; you will need them only in rare and specific circumstances.
Our goal here is therefore to explain \subind{variable}{pool} variables just enough so that you can understand them when you are reading code. 

A class that accesses a pool variable must mention the pool in its class definition. 
For example, the class \clsind{Text} 
indicates that it is using the pool dictionary \ct{TextConstants}, which contains all the text constants such as \glbind{CR} and \glbind{LF}. 
This dictionary has a key \ct{#CR} that is bound to the value \ct{Character cr}, \ie the carriage return character.
\cmindex{Character class}{cr}

\begin{classdef}[textpooldict]{Pool dictionaries in the \ct{Text} class}
ArrayedCollection subclass: #Text
        instanceVariableNames: 'string runs' 	
        classVariableNames: '' 	
        !\textbf{poolDictionaries: 'TextConstants'}!
        category: 'Collections-Text'
\end{classdef}
   
This allows methods of the class \ct{Text} to access the keys of the dictionary in the method body \emph{directly}, \ie by using variable syntax rather than an explicit dictionary lookup.
For example, we can write the following method. 
  
\begin{method}[texttestcr]{Text>>testCR}
Text>>>testCR 	
      ^ CR == Character cr
\end{method}

Once again,  we recommend that you avoid the use of pool variables and pool dictionaries. 

%=========================================================
\section{Chapter summary}

The object model of \pharo is both simple and uniform.
Everything is an object, and pretty much everything happens by sending messages.

\begin{itemize}
  \item Everything is an object.
  Primitive entities like integers are objects, but also classes are first-class objects.

  \item Every object is an instance of a class.
  Classes define the structure of their instances via \emph{private} instance variables and the behaviour of their instances via \emph{public} methods. Each class is the unique instance of its metaclass.  Class variables are private variables shared by the class and all the instances of the class.
  Classes cannot directly access instance variables of their instances, and instances cannot access instance variables of their class.
  Accessors must be defined if this is needed.

  \item Every class has a superclass.
  The root of the single inheritance hierarchy is \lct{ProtoObject}.
  Classes you define, however, should normally inherit from \ct{Object} or its subclasses.
  There is no syntax for defining abstract classes.
  An abstract class is simply a class with an abstract method\,---\,one 
  whose implementation consists of the expression \ct{self subclassResponsibility}.
  Although \pharo supports only single inheritance, it is easy to share implementations of methods by packaging them as \emph{traits}.

  \item Everything happens by sending messages.
	We do not ``call methods'', we ``send messages''.
	The receiver then chooses its own method for responding to the message.

  \item Method lookup follows the inheritance chain;
  \self sends are dynamic and start the method lookup again in the class of the receiver, whereas
  \super sends are static, and start in the superclass of class in which the \super send is written.
  
  \item There are three kinds of shared variables.
  		Global variables are accessible everywhere in the system.
		Class variables are shared between a class, its subclasses and its instances.
		Pool variables are shared between a selected set of classes.
		You should avoid shared variables as much as possible.

\end{itemize}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%=================================================================
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:

%---------------------------------------------------------
